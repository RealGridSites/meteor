<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <!-- Basic -->
    <title>Publications and Data Loading | Meteor Guide</title>
    <meta name="description" content="How and where to load data in your Meteor app using publications and subscriptions.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../images/favicon.png" sizes="16x16 32x32 64x64">

    <!-- Social -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="http://meteor.realgrid.com">
    <meta property="og:title" content="Publications and Data Loading | Meteor Guide">
    <meta property="og:description" content="How and where to load data in your Meteor app using publications and subscriptions.">
    <meta property="og:image" content="">
    <meta name="twitter:card" content="summary_image_large">
    <meta name="twitter:site" content="@meteor">
    <meta name="twitter:title" content="Publications and Data Loading | Meteor Guide">
    <meta name="twitter:description" content="How and where to load data in your Meteor app using publications and subscriptions.">
    <meta name="twitter:image" content="">

    <!-- Misc -->
    <meta name="google-site-verification" content="" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,200,300italic,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/style/style.css">
  </head>
  <body class="">
    

<div class="nav dark">
  <div class="nav-group">
    <div class="nav-item show-mobile">
      <span class="js-sidebar-toggle ">
        <span class="icon-menu"></span>
      </span>
    </div>
    <div class="nav-item">
      <a class="logo-wrapper" href="http://www.meteor.com/developers" title="Meteor Developers Developers"  >
        <img src="../images/logo-coralspace-left.svg" alt="Meteor Developers" class="logo"/>
        <span>Developers</span>
      </a>
    </div>
  </div>

  <div class="nav-group right">
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="http://www.meteor.com/tutorials" target=_new >
          <span>Tutorials</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop active ">
        <a class="link" href="http://guide.meteor.com"  >
          <span>Guide</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="http://docs.meteor.com"  >
          <span>API Docs</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="https://forums.meteor.com/" target=_new >
          <span>Forums</span>
        </a>
      </div>
    
  </div>
</div>

<div class="sidebar">
  <div class="panel">
    <div class="panel-item">
      <a class="" href="http://www.meteor.com/developers" title="Meteor Developers"  >
        <span>Meteor Developers Developers</span>
      </a>
    </div>
    
      <div class="panel-item "">
        <a class="" href="http://www.meteor.com/tutorials" target=_new >
          <span>Tutorials</span>
        </a>
      </div>
    
      <div class="panel-item active"">
        <a class="" href="http://guide.meteor.com"  >
          <span>Guide</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://docs.meteor.com"  >
          <span>API Docs</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="https://forums.meteor.com/" target=_new >
          <span>Forums</span>
        </a>
      </div>
    
  </div>

  <div class="sidebar-content">
    <div class="topcap">
      <span class="title-sidebar">Meteor Guide</span>
      
        <span class="select version-sidebar nochrome">
          <select class="version-select">
            
              <option value="v1.4">1.4</option>
            
              <option value="v1.3">1.3</option>
            
              <option value="v1.2">1.2</option>
            
          </select>
        </span>
      
    </div>

    
    <div class="wrapper-search">
      <div class="input-symbol small round">
        <input type="text" placeholder="Search The Official Guide" id="desktop-search-input" />
        <span class="icon-search"></span>
      </div>
      <div class="wrapper-desktop-search-results"></div>
    </div>

    

    <ul class="toc">
      
        <li>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="index.html" class="sidebar-link ">
                  <span>Introduction</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="code-style.html" class="sidebar-link ">
                  <span>Code Style</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="structure.html" class="sidebar-link ">
                  <span>Application Structure</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="1.4-migration.html" class="sidebar-link ">
                  <span>Migrating to Meteor 1.4</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="1.3-migration.html" class="sidebar-link ">
                  <span>Migrating to Meteor 1.3</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Data</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="collections.html" class="sidebar-link ">
                  <span>Collections and Schemas</span>
                </a>
              </li>
            
              
              <li class="item-toc  current">
                <a href="" class="sidebar-link  current">
                  <span>Publications and Data Loading</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="methods.html" class="sidebar-link ">
                  <span>Methods</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="accounts.html" class="sidebar-link ">
                  <span>Users and Accounts</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="testing.html" class="sidebar-link ">
                  <span>Testing</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">View</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="routing.html" class="sidebar-link ">
                  <span>URLs and Routing</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="ui-ux.html" class="sidebar-link ">
                  <span>User Interfaces</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="blaze.html" class="sidebar-link ">
                  <span>Blaze</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="react.html" class="sidebar-link ">
                  <span>React</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="angular.html" class="sidebar-link ">
                  <span>Angular</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Build</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="atmosphere-vs-npm.html" class="sidebar-link ">
                  <span>Atmosphere vs. npm</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="using-atmosphere-packages.html" class="sidebar-link ">
                  <span>Using Atmosphere Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="writing-atmosphere-packages.html" class="sidebar-link ">
                  <span>Writing Atmosphere Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="using-npm-packages.html" class="sidebar-link ">
                  <span>Using npm Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="writing-npm-packages.html" class="sidebar-link ">
                  <span>Writing npm Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="mobile.html" class="sidebar-link ">
                  <span>Mobile</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="build-tool.html" class="sidebar-link ">
                  <span>Build System</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Production</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="security.html" class="sidebar-link ">
                  <span>Security</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="deployment.html" class="sidebar-link ">
                  <span>Deployment and Monitoring</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Meta</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="CONTRIBUTING.html" class="sidebar-link ">
                  <span>Contribution Guidelines</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="CHANGELOG.html" class="sidebar-link ">
                  <span>Changelog</span>
                </a>
              </li>
            
          </ul>
        </li>
      
    </ul>
  </div>
</div>

<div class="content">
  <div class="content-wrapper">
    <div class="header-content">
      <h1 class="title-page">Publications and Data Loading</h1>
      
        <div class="subtitle-page">How and where to load data in your Meteor app using publications and subscriptions.</div>
      

      <div class="page-actions">
        <div class="actions-group">
          <a class="btn tertiary small round lowercase" href="https://github.com/meteor/guide/tree/master/content/data-loading.md" target="_blank"><span class="icon-github"></span> <span>Edit on GitHub</span></a>
          
            <a class="btn tertiary small round lowercase" href="https://forums.meteor.com/t/19661"><span class="icon-comment"></span> <span>Discuss</span></a>
          
        </div>
      </div>
    </div>

    <div class="document-formatting">
      <p>After reading this guide, you’ll know:</p>
<ol>
<li>What publications and subscriptions are in the Meteor platform.</li>
<li>How to define a publication on the server.</li>
<li>Where to subscribe on the client and in which templates.</li>
<li>Useful patterns for managing subscriptions.</li>
<li>How to reactively publish related data.</li>
<li>How to ensure your publication is secure in the face of reactive changes.</li>
<li>How to use the low-level publish API to publish anything.</li>
<li>What happens when you subscribe to a publication.</li>
<li>How to turn a 3rd-party REST endpoint into a publication.</li>
<li><p>How to turn a publication in your app into a REST endpoint.</p>
</li>
<li><p>Meteor 플랫폼에서 출판(publications)과 구독(subscriptions)이 무엇인지.</p>
</li>
<li>서버에서 출판을 정의하는 방법.</li>
<li>클라이언트의 어디에서, 또 어떤 템플릿에서 구독하는지.</li>
<li>구독 관리를 위한 유용한 패턴.</li>
<li>관련 데이터를 반응적(reactively)으로 구독하는 방법</li>
<li>반응적인 변화(reactive changes)에 대해 출판물을 안전하게 보호하는 방법.</li>
<li>낮은 수준의 출판 API를 사용하여 모든 것을 출판하는 방법</li>
<li>출판물을 구독하면 어떤일이 일어나는가?</li>
<li>타사 REST 끝점을 게시로 변환하는 방법</li>
<li>앱에서 발행물을 REST 엔드 포인트로 변환하는 방법.</li>
</ol>
<h2 id="publications-and-subscriptions">Publications and subscriptions</h2>

<p>In a traditional, HTTP-based web application, the client and server communicate in a “request-response” fashion. Typically the client makes RESTful HTTP requests to the server and receives HTML or JSON data in response, and there’s no way for the server to “push” data to the client when changes happen at the backend.</p>
<p>Meteor is built from the ground up on the Distributed Data Protocol (DDP) to allow data transfer in both directions. Building a Meteor app doesn’t require you to set up REST endpoints to serialize and send data. Instead you create <em>publication</em> endpoints that can push data from server to client.</p>
<p>In Meteor a <strong>publication</strong> is a named API on the server that constructs a set of data to send to a client. A client initiates a <strong>subscription</strong> which connects to a publication, and receives that data. That data consists of a first batch sent when the subscription is initialized and then incremental updates as the published data changes.</p>
<p>So a subscription can be thought of as a set of data that changes over time. Typically, the result of this is that a subscription “bridges” a <a href="/collections.html#server-collections">server-side MongoDB collection</a>, and the <a href="collections.html#client-collections">client side Minimongo cache</a> of that collection. You can think of a subscription as a pipe that connects a subset of the “real” collection with the client’s version, and constantly keeps it up to date with the latest information on the server.</p>
<h2 id="publications">Defining a publication</h2>

<p>A publication should be defined in a server-only file. For instance, in the Todos example app, we want to publish the set of public lists to all users:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'lists.public'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Lists.find(&#123;</span><br><span class="line">    <span class="attr">userId</span>: &#123;<span class="attr">$exists</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">fields</span>: Lists.publicFields</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>There are a few things to understand about this code block. First, we’ve named the publication with the unique string <code>lists.public</code>, and that will be how we access it from the client. Second, we are simply returning a Mongo <em>cursor</em> from the publication function. Note that the cursor is filtered to only return certain fields from the collection, as detailed in the <a href="security.html#fields">Security article</a>.</p>
<p>What that means is that the publication will simply ensure the set of data matching that query is available to any client that subscribes to it. In this case, all lists that do not have a <code>userId</code> setting. So the collection named <code>Lists</code> on the client will have all of the public lists that are available in the server collection named <code>Lists</code> while that subscription is open. In this particular example in the Todos application, the subscription is initialized when the app starts and never stopped, but a later section will talk about <a href="data-loading.html#patterns">subscription life cycle</a>.</p>
<p>Every publication takes two types of parameters:</p>
<ol>
<li>The <code>this</code> context, which has information about the current DDP connection. For example, you can access the current user’s <code>_id</code> with <code>this.userId</code>.</li>
<li>The arguments to the publication, which can be passed in when calling <code>Meteor.subscribe</code>.</li>
</ol>
<blockquote>
<p>Note: Since we need to access context on <code>this</code> we need to use the <code>function() {}</code> form for publications rather than the ES2015 <code>() =&gt; {}</code>. You can disable the arrow function linting rule for publication files with <code>eslint-disable prefer-arrow-callback</code>. A future version of the publication API will work more nicely with ES2015.</p>
</blockquote>
<p>In this publication, which loads private lists, we need to use <code>this.userId</code> to get only the todo lists that belong to a specific user.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'lists.private'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.userId) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ready();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Lists.find(&#123;</span><br><span class="line">    <span class="attr">userId</span>: <span class="keyword">this</span>.userId</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">fields</span>: Lists.publicFields</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Thanks to the guarantees provided by DDP and Meteor’s accounts system, the above publication can be confident that it will only ever publish private lists to the user that they belong to. Note that the publication will re-run if the user logs out (or back in again), which means that the published set of private lists will change as the active user changes.</p>
<p>In the case of a logged-out user, we explicitly call <code>this.ready()</code>, which indicates to the subscription that we’ve sent all the data we are initially going to send (in this case none). It’s important to know that if you don’t return a cursor from the publication or call <code>this.ready()</code>, the user’s subscription will never become ready, and they will likely see a loading state forever.</p>
<p>Here’s an example of a publication which takes a named argument. Note that it’s important to check the types of arguments that come in over the network.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'todos.inList'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">listId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We need to check the `listId` is the type we expect</span></span><br><span class="line">  <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">listId</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;</span><br><span class="line">  &#125;).validate(&#123; listId &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>When we subscribe to this publication on the client, we can provide this argument via the <code>Meteor.subscribe()</code> call:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Meteor.subscribe(<span class="string">'todos.inList'</span>, list._id);</span><br></pre></td></tr></table></figure>
<h3 id="organization-publications">Organizing publications</h3>

<p>It makes sense to place a publication alongside the feature that it’s targeted for. For instance, sometimes publications provide very specific data that’s only really useful for the view for which they were developed. In that case, placing the publication in the same module or directory as the view code makes perfect sense.</p>
<p>Often, however, a publication is more general. For example in the Todos example application, we create a <code>todos.inList</code> publication, which publishes all the todos in a list. Although in the application we only use this in one place (in the <code>Lists_show</code> template), in a larger app, there’s a good chance we might need to access all the todos for a list in other places. So putting the publication in the <code>todos</code> package is a sensible approach.</p>
<h2 id="subscriptions">Subscribing to data</h2>

<p>To use publications, you need to create a subscription to it on the client. To do so, you call <code>Meteor.subscribe()</code> with the name of the publication. When you do this, it opens up a subscription to that publication, and the server starts sending data down the wire to ensure that your client collections contain up to date copies of the data specified by the publication.</p>
<p><code>Meteor.subscribe()</code> also returns a “subscription handle” with a property called <code>.ready()</code>. This is a reactive function that returns <code>true</code> when the publication is marked ready (either you call <code>this.ready()</code> explicitly, or the initial contents of a returned cursor are sent over).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = Meteor.subscribe(<span class="string">'lists.public'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="stopping-subscriptions">Stopping Subscriptions</h3>

<p>The subscription handle also has another important property, the <code>.stop()</code> method. When you are subscribing, it is very important to ensure that you always call <code>.stop()</code> on the subscription when you are done with it. This ensures that the documents sent by the subscription are cleared from your local Minimongo cache and the server stops doing the work required to service your subscription. If you forget to call stop, you’ll consume unnecessary resources both on the client and the server.</p>
<p><em>However</em>, if you call <code>Meteor.subscribe()</code> conditionally inside a reactive context (such as an <code>autorun</code>, or <code>getMeteorData</code> in React) or via <code>this.subscribe()</code> in a Blaze component, then Meteor’s reactive system will automatically call <code>this.stop()</code> for you at the appropriate time.</p>
<h3 id="organizing-subscriptions">Subscribe in UI components</h3>

<p>It is best to place the subscription as close as possible to the place where the data from the subscription is needed. This reduces “action at a distance” and makes it easier to understand the flow of data through your application. If the subscription and fetch are separated, then it’s not always clear how and why changes to the subscriptions (such as changing arguments), will affect the contents of the cursor.</p>
<p>What this means in practice is that you should place your subscription calls in <em>components</em>. In Blaze, it’s best to do this in the <code>onCreated()</code> callback:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Template.Lists_show_page.onCreated(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.getListId = <span class="function"><span class="params">()</span> =&gt;</span> FlowRouter.getParam(<span class="string">'_id'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribe(<span class="string">'todos.inList'</span>, <span class="keyword">this</span>.getListId());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>In this code snippet we can see two important techniques for subscribing in Blaze templates:</p>
<ol>
<li><p>Calling <code>this.subscribe()</code> (rather than <code>Meteor.subscribe</code>), which attaches a special <code>subscriptionsReady()</code> function to the template instance, which is true when all subscriptions made inside this template are ready.</p>
</li>
<li><p>Calling <code>this.autorun</code> sets up a reactive context which will re-initialize the subscription whenever the reactive function <code>this.getListId()</code> changes.</p>
</li>
</ol>
<p>Read more about Blaze subscriptions in the <a href="blaze.html#subscribing">Blaze article</a>, and about tracking loading state inside UI components in the <a href="ui-ux.html#subscription-readiness">UI article</a>.</p>
<h3 id="fetching">Fetching data</h3>

<p>Subscribing to data puts it in your client-side collection. To use the data in your user interface, you need to query your client-side collection. There are a couple of important rules to follow when doing this.</p>
<h4 id="specific-queries">Always use specific queries to fetch data</h4>

<p>If you’re publishing a subset of your data, it might be tempting to simply query for all data available in a collection (i.e. <code>Lists.find()</code>) in order to get that subset on the client, without re-specifying the Mongo selector you used to publish that data in the first place.</p>
<p>But if you do this, then you open yourself up to problems if another subscription pushes data into the same collection, since the data returned by <code>Lists.find()</code> might not be what you expected anymore. In an actively developed application, it’s often hard to anticipate what may change in the future and this can be a source of hard to understand bugs.</p>
<p>Also, when changing between subscriptions, there is a brief period where both subscriptions are loaded (see <a href="#publication-behavior-with-arguments">Publication behavior when changing arguments</a> below), so when doing things like pagination, it’s exceedingly likely that this will be the case.</p>
<h4 id="fetch-near-subscribe">Fetch the data nearby where you subscribed to it</h4>

<p>We do this for the same reason we subscribe in the component in the first place—to avoid action at a distance and to make it easier to understand where data comes from. A common pattern is to fetch the data in a parent template, and then pass it into a “pure” child component, as we’ll see it in the <a href="ui-ux.html#components">UI Article</a>.</p>
<p>Note that there are some exceptions to this second rule. A common one is <code>Meteor.user()</code>—although this is strictly speaking subscribed to (automatically usually), it’s typically over-complicated to pass it through the component hierarchy as an argument to each component. However keep in mind it’s best not to use it in too many places as it makes components harder to test.</p>
<h3 id="global-subscriptions">Global subscriptions</h3>

<p>One place where you might be tempted to not subscribe inside a component is when it accesses data that you know you <em>always</em> need. For instance, a subscription to extra fields on the user object (see the <a href="accounts.html">Accounts Article</a>) that you need on every screen of your app.</p>
<p>However, it’s generally a good idea to use a layout component (which you wrap all your components in) to subscribe to this subscription anyway. It’s better to be consistent about such things, and it makes for a more flexible system if you ever decide you have a screen that <em>doesn’t</em> need that data.</p>
<h2 id="patterns">Patterns for data loading</h2>

<p>Across Meteor applications, there are some common patterns of data loading and management on the client side that are worth knowing. We’ll go into more detail about some of these in the <a href="ui-ux.html">UI/UX Article</a>.</p>
<p>Meteor 응용 프로그램에는 클라이언트 측에서 알고 있어야 할 가치가있는 몇 가지 공통 패턴의 데이터로드 및 관리가 있습니다. UI / UX 기사에서 이들 중 일부에 대해 자세히 설명하겠습니다.</p>
<h3 id="readiness">Subscription readiness</h3>

<p>It is key to understand that a subscription will not instantly provide its data. There will be a latency between subscribing to the data on the client and it arriving from the publication on the server. You should also be aware that this delay may be a lot longer for your users in production than for you locally in development!</p>
<p>구독은 즉시 데이터를 제공하지 않는다는 것을 이해하는 것이 중요합니다. 클라이언트의 데이터를 구독 할 때와 서버의 게시에서 도착할 때 사이에 대기 시간이 있습니다. 또한이 지연은 개발중인 로컬 사용자보다 프로덕션 사용자가 훨씬 더 오래 걸릴 수 있음을 알아야합니다.</p>
<p>Although the Tracker system means you often don’t <em>need</em> to think too much about this in building your apps, usually if you want to get the user experience right, you’ll need to know when the data is ready.</p>
<p>트래커 시스템을 사용하여 앱을 제작할 때 이 점을 너무 많이 생각할 필요는 없지만 일반적으로 사용자 환경을 올바르게 사용하려면 데이터 준비가 언제인지를 알아야합니다.</p>
<p>To find that out, <code>Meteor.subscribe()</code> and (<code>this.subscribe()</code> in Blaze components) returns a “subscription handle”, which contains a reactive data source called <code>.ready()</code>:</p>
<p>이를 확인하기 위해, Blaze 구성 요소의 Meteor.subscribe () 및 (this.subscribe ())는 .ready ()라는 반응적인 데이터 소스를 포함하는 “가입 핸들”을 반환합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = Meteor.subscribe(<span class="string">'lists.public'</span>);</span><br><span class="line">Tracker.autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isReady = handle.ready();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Handle is <span class="subst">$&#123;isReady ? <span class="string">'ready'</span> : <span class="string">'not ready'</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>We can use this information to be more subtle about when we try and show data to users, and when we show a loading screen.</p>
<h3 id="changing-arguments">Reactively changing subscription arguments</h3>

<p>We’ve already seen an example of using an <code>autorun</code> to re-subscribe when the (reactive) arguments to a subscription change. It’s worth digging in a little more detail to understand what happens in this scenario.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Template.Lists_show_page.onCreated(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.getListId = <span class="function"><span class="params">()</span> =&gt;</span> FlowRouter.getParam(<span class="string">'_id'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribe(<span class="string">'todos.inList'</span>, <span class="keyword">this</span>.getListId());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>In our example, the <code>autorun</code> will re-run whenever <code>this.getListId()</code> changes, (ultimately because <code>FlowRouter.getParam(&#39;_id&#39;)</code> changes), although other common reactive data sources are:</p>
<ol>
<li>Template data contexts (which you can access reactively with <code>Template.currentData()</code>).</li>
<li>The current user status (<code>Meteor.user()</code> and <code>Meteor.loggingIn()</code>).</li>
<li>The contents of other application specific client data stores.</li>
</ol>
<p>Technically, what happens when one of these reactive sources changes is the following:</p>
<ol>
<li>The reactive data source <em>invalidates</em> the autorun computation (marks it so that it re-runs in the next Tracker flush cycle).</li>
<li>The subscription detects this, and given that anything is possible in next computation run, marks itself for destruction.</li>
<li>The computation re-runs, with <code>.subscribe()</code> being re-called either with the same or different arguments.</li>
<li>If the subscription is run with the <em>same arguments</em> then the “new” subscription discovers the old “marked for destruction” subscription that’s sitting around, with the same data already ready, and simply reuses that.</li>
<li>If the subscription is run with <em>different arguments</em>, then a new subscription is created, which connects to the publication on the server.</li>
<li>At the end of the flush cycle (i.e. after the computation is done re-running), the old subscription checks to see if it was re-used, and if not, sends a message to the server to tell the server to shut it down.</li>
</ol>
<p>Step 4 above is an important detail—that the system cleverly knows not to re-subscribe if the autorun re-runs and subscribes with the exact same arguments. This holds true even if the new subscription is set up somewhere else in the template hierarchy. For example, if a user navigates between two pages that both subscribe to the exact same subscription, the same mechanism will kick in and no unnecessary subscribing will happen.</p>
<h3 id="publication-behavior-with-arguments">Publication behavior when arguments change</h3>

<p>It’s also worth knowing a little about what happens on the server when the new subscription is started and the old one is stopped.</p>
<p>The server <em>explicitly</em> waits until all the data is sent down (the new subscription is ready) for the new subscription before removing the data from the old subscription. The idea here is to avoid flicker—you can, if desired, continue to show the old subscription’s data until the new data is ready, then instantly switch over to the new subscription’s complete data set.</p>
<p>What this means is in general, when changing subscriptions, there’ll be a period where you are <em>over-subscribed</em> and there is more data on the client than you strictly asked for. This is one very important reason why you should always fetch the same data that you have subscribed to (don’t “over-fetch”).</p>
<h3 id="pagination">Paginating subscriptions</h3>

<p>A very common pattern of data access is pagination. This refers to the practice of fetching an ordered list of data one “page” at a time—typically some number of items, say twenty.</p>
<p>매우 일반적인 데이터 액세스 패턴은 페이지 매김입니다. 이것은 한 번에 하나의 “페이지”, 일반적으로 몇 가지 항목, 예를 들어 20 개의 정렬 된 데이터 목록을 가져 오는 관행을 의미합니다.</p>
<p>There are two styles of pagination that are commonly used, a “page-by-page” style—where you show only one page of results at a time, starting at some offset (which the user can control), and “infinite-scroll” style, where you show an increasing number of pages of items, as the user moves through the list (this is the typical “feed” style user interface).</p>
<p>일반적으로 사용되는 페이지 스타일에는 사용자가 제어 할 수있는 오프셋 (offset) (한 번에 한 페이지 만 표시)과 “무한 스크롤 (infinite-scroll)” “스타일로 사용자가 목록을 이동하면서 점점 더 많은 수의 항목 페이지를 표시합니다 (일반적인”피드 “스타일 사용자 인터페이스).</p>
<p>In this section, we’ll consider a publication/subscription technique for the second, infinite-scroll style pagination. The page-by-page technique is a little tricker to handle in Meteor, due to it being difficult to calculate the offset on the client. If you need to do so, you can follow many of the same techniques that we use here and use the <a href="https://atmospherejs.com/percolate/find-from-publication" target="_blank" rel="external"><code>percolate:find-from-publication</code></a> package to keep track of which records have come from your publication.</p>
<p>이 섹션에서는 무한 스크롤 스타일의 두 번째 페이지 매김에 대한 게시 / 가입 기술을 살펴 보겠습니다. 페이지 별 기법은 클라이언트에서 오프셋을 계산하기가 어렵 기 때문에 Meteor에서 처리하기에는 조금 까다 롭습니다. 그렇게해야 할 경우 여기에서 사용하는 것과 동일한 기술을 많이 사용하고 게시판 찾기 패키지를 사용하여 어떤 레코드가 발행물에서 왔는지 추적 할 수 있습니다.</p>
<p>In an infinite scroll publication, we simply need to add a new argument to our publication controlling how many items to load. Suppose we wanted to paginate the todo items in our Todos example app:</p>
<p>무한한 스크롤 출판물에서는로드 할 아이템 수를 제어하는 ​​새로운 인수를 발행물에 추가하기 만하면됩니다. Todos 예제 애플리케이션에서 할 일 항목에 페이지 매김을 수행한다고 가정 해 보겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_TODOS = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">Meteor.publish(<span class="string">'todos.inList'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">listId, limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">listId</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">    <span class="attr">limit</span>: &#123; <span class="attr">type</span>: <span class="built_in">Number</span> &#125;</span><br><span class="line">  &#125;).validate(&#123; listId, limit &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">sort</span>: &#123;<span class="attr">createdAt</span>: <span class="number">-1</span>&#125;,</span><br><span class="line">    <span class="attr">limit</span>: <span class="built_in">Math</span>.min(limit, MAX_TODOS)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>It’s important that we set a <code>sort</code> parameter on our query (to ensure a repeatable order of list items as more pages are requested), and that we set an absolute maximum on the number of items a user can request (at least in the case where lists can grow without bound).</p>
<p>질의에 정렬 매개 변수를 설정하는 것이 중요합니다 (더 많은 페이지가 요청 될 때 목록 항목의 반복 가능한 순서를 유지하기 위해). 그리고 사용자가 요청할 수있는 항목의 수에 대해 절대 최대 값을 설정해야합니다. 목록은 바운드없이 성장할 수 있음).</p>
<p>Then on the client side, we’d set some kind of reactive state variable to control how many items to request:</p>
<p>그런 다음 클라이언트 측에서 요청할 아이템 수를 제어하기 위해 일종의 반응 상태 변수를 설정합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Template.Lists_show_page.onCreated(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.getListId = <span class="function"><span class="params">()</span> =&gt;</span> FlowRouter.getParam(<span class="string">'_id'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribe(<span class="string">'todos.inList'</span>,</span><br><span class="line">      <span class="keyword">this</span>.getListId(), <span class="keyword">this</span>.state.get(<span class="string">'requestedTodos'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>We’d increment that <code>requestedTodos</code> variable when the user clicks “load more” (or perhaps just when they scroll to the bottom of the page).</p>
<p>사용자가 “더로드”를 클릭하면 (또는 페이지 맨 아래로 스크롤 할 때) requestTodos 변수를 증가시킵니다.</p>
<p>One piece of information that’s very useful to know when paginating data is the <em>total number of items</em> that you could see. The <a href="https://atmospherejs.com/tmeasday/publish-counts" target="_blank" rel="external"><code>tmeasday:publish-counts</code></a> package can be useful to publish this. We could add a <code>Lists.todoCount</code> publication like so</p>
<p>페이지 매김 데이터를 볼 수있는 항목의 총 개수를 알면 매우 유용한 한 가지 정보입니다. tmeasday : publish-counts 패키지는 이것을 게시하는 데 유용 할 수 있습니다. 우리는 Lists.todoCount 출판물을 이렇게 추가 할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'Lists.todoCount'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">&#123; listId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">listId</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;</span><br><span class="line">  &#125;).validate(&#123; listId &#125;);</span><br><span class="line"></span><br><span class="line">  Counts.publish(<span class="keyword">this</span>, <span class="string">`Lists.todoCount.<span class="subst">$&#123;listId&#125;</span>`</span>, Todos.find(&#123;listId&#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Then on the client, after subscribing to that publication, we can access the count with</p>
<p>그런 다음 클라이언트에서 해당 게시판을 구독하면</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counts.get(<span class="string">`Lists.todoCount.<span class="subst">$&#123;listId&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<h2 id="stores">Client-side data with reactive stores</h2>

<p>In Meteor, persistent or shared data comes over the wire on publications. However, there are some types of data which doesn’t need to be persistent or shared between users. For instance, the “logged-in-ness” of the current user, or the route they are currently viewing.</p>
<p>Although client-side state is often best contained as state of an individual template (and passed down the template hierarchy as arguments where necessary), sometimes you have a need for “global” state that is shared between unrelated sections of the template hierarchy.</p>
<p>Usually such state is stored in a <em>global singleton</em> object which we can call a store. A singleton is a data structure of which only a single copy logically exists. The current user and the router from above are typical examples of such global singletons.</p>
<h3 id="store-types">Types of stores</h3>

<p>In Meteor, it’s best to make stores <em>reactive data</em> sources, as that way they tie most naturally into the rest of the ecosystem. There are a few different packages you can use for stores.</p>
<p>If the store is single-dimensional, you can probably use a <code>ReactiveVar</code> to store it (provided by the <a href="https://atmospherejs.com/meteor/reactive-var" target="_blank" rel="external"><code>reactive-var</code></a> package). A <code>ReactiveVar</code> has two properties, <code>get()</code> and <code>set()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DocumentHidden = <span class="keyword">new</span> ReactiveVar(<span class="built_in">document</span>.hidden);</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'visibilitychange'</span>, (event) =&gt; &#123;</span><br><span class="line">  DocumentHidden.set(<span class="built_in">document</span>.hidden);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>If the store is multi-dimensional, you may want to use a <code>ReactiveDict</code> (from the <a href="https://atmospherejs.com/meteor/reactive-dict" target="_blank" rel="external"><code>reactive-dict</code></a> package):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $<span class="built_in">window</span> = $(<span class="built_in">window</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDimensions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: $<span class="built_in">window</span>.width(),</span><br><span class="line">    <span class="attr">height</span>: $<span class="built_in">window</span>.height()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WindowSize = <span class="keyword">new</span> ReactiveDict();</span><br><span class="line">WindowSize.set(getDimensions());</span><br><span class="line">$<span class="built_in">window</span>.on(<span class="string">'resize'</span>, () =&gt; &#123;</span><br><span class="line">  WindowSize.set(getDimensions());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The advantage of a <code>ReactiveDict</code> is you can access each property individually (<code>WindowSize.get(&#39;width&#39;)</code>), and the dict will diff the field and track changes on it individually (so your template will re-render less often for instance).</p>
<p>If you need to query the store, or store many related items, it’s probably a good idea to use a Local Collection (see the <a href="collections.html#local-collections">Collections Article</a>).</p>
<h3 id="accessing-stores">Accessing stores</h3>

<p>You should access stores in the same way you’d access other reactive data in your templates—that means centralizing your store access, much like you centralize your subscribing and data fetch. For a Blaze template, that’s either in a helper, or from within a <code>this.autorun()</code> inside an <code>onCreated()</code> callback.</p>
<p>This way you get the full reactive power of the store.</p>
<h3 id="updating-stores">Updating stores</h3>

<p>If you need to update a store as a result of user action, you’d update the store from an event handler, just like you call <a href="methods.html">Methods</a>.</p>
<p>If you need to perform complex logic in the update (e.g. not just call <code>.set()</code> etc), it’s a good idea to define a mutator on the store. As the store is a singleton, you can just attach a function to the object directly:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WindowSize.simulateMobile = <span class="function">(<span class="params">device</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (device === <span class="string">'iphone6s'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.set(&#123;<span class="attr">width</span>: <span class="number">750</span>, <span class="attr">height</span>: <span class="number">1334</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="advanced-publications">Advanced publications</h2>

<p>Sometimes, the simple mechanism of returning a query from a publication function won’t cover your needs. In those situations, there are some more powerful publication patterns that you can use.</p>
<p>때로는 게시 함수에서 쿼리를 반환하는 간단한 메커니즘이 사용자의 요구를 다루지는 않습니다. 이러한 상황에서 사용할 수있는 좀 더 강력한 게시 패턴이 있습니다.</p>
<h3 id="publishing-relations">Publishing relational data</h3>

<p>It’s common to need related sets of data from multiple collections on a given page. For instance, in the Todos app, when we render a todo list, we want the list itself, as well as the set of todos that belong to that list.</p>
<p>특정 페이지에서 여러 컬렉션의 관련 데이터 세트가 필요합니다. 예를 들어 Todos 앱에서 할일 목록을 렌더링 할 때 목록 자체와 해당 목록에 속한 할일 목록이 필요합니다.</p>
<p>One way you might do this is to return more than one cursor from your publication function:</p>
<p>한 가지 방법은 게시 함수에서 커서를 두 개 이상 반환하는 것입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'todos.inList'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">listId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">listId</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;</span><br><span class="line">  &#125;).validate(&#123; listId &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> list = Lists.findOne(listId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (list &amp;&amp; (!list.userId || list.userId === <span class="keyword">this</span>.userId)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      Lists.find(listId),</span><br><span class="line">      Todos.find(&#123;listId&#125;)</span><br><span class="line">    ];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The list doesn't exist, or the user isn't allowed to see it.</span></span><br><span class="line">    <span class="comment">// In either case, make it appear like there is no list.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ready();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>However, this example will not work as you might expect. The reason is that reactivity doesn’t work in the same way on the server as it does on the client. On the client, if <em>anything</em> in a reactive function changes, the whole function will re-run, and the results are fairly intuitive.</p>
<p>그러나이 예는 예상대로 작동하지 않습니다. 그 이유는 반응성이 클라이언트에서와 같은 방식으로 서버에서 작동하지 않기 때문입니다. 클라이언트에서는 반응 함수가 변경되면 함수 전체가 다시 실행되고 그 결과는 매우 직관적입니다.</p>
<p>On the server however, the reactivity is limited to the behavior of the cursors you return from your publish functions. You’ll see any changes to the data that matches their queries, but <em>their queries will never change</em>.</p>
<p>그러나 서버에서는 반응 기능이 게시 기능에서 반환하는 커서의 동작으로 제한됩니다. 검색어와 일치하는 데이터의 변경 사항이 표시되지만 검색어는 변경되지 않습니다.</p>
<p>So in the case above, if a user subscribes to a list that is later made private by another user, although the <code>list.userId</code> will change to a value that no longer passes the condition, the body of the publication will not re-run, and so the query to the <code>Todos</code> collection (<code>{listId}</code>) will not change. So the first user will continue to see items they shouldn’t.</p>
<p>따라서 위의 경우 사용자가 나중에 다른 사용자가 비공개로 만든 목록에 가입하면 list.userId가 조건을 더 이상 통과하지 않는 값으로 변경 되더라도 게시 본문이 다시 실행되지 않고, 따라서 Todos 컬렉션 ({listId})에 대한 쿼리는 변경되지 않습니다. 따라서 첫 번째 사용자는 계속 가져야하는 항목을 계속 보게됩니다.</p>
<p>However, we can write publications that are properly reactive to changes across collections. To do this, we use the <a href="https://atmospherejs.com/reywood/publish-composite" target="_blank" rel="external"><code>reywood:publish-composite</code></a> package.</p>
<p>그러나 우리는 컬렉션 전체의 변경 사항에 적절하게 대응하는 발행물을 작성할 수 있습니다. 이렇게하려면 reywood : publish-composite 패키지를 사용합니다.</p>
<p>The way this package works is to first establish a cursor on one collection, and then explicitly set up a second level of cursors on a second collection with the results of the first cursor. The package uses a query observer behind the scenes to trigger the subscription to change and queries to re-run whenever the source data changes.</p>
<p>이 패키지가 작동하는 방식은 먼저 한 모음에 커서를 설정 한 다음 첫 번째 커서의 결과로 두 번째 모음에 두 번째 수준의 커서를 명시 적으로 설정하는 것입니다. 패키지는 장면 뒤의 쿼리 관찰자를 사용하여 원본 데이터가 변경 될 때마다 구독을 변경하고 쿼리하여 다시 실행하도록합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publishComposite(<span class="string">'todos.inList'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">listId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">listId</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;</span><br><span class="line">  &#125;).validate(&#123; listId &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> userId = <span class="keyword">this</span>.userId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    find() &#123;</span><br><span class="line">      <span class="keyword">const</span> query = &#123;</span><br><span class="line">        <span class="attr">_id</span>: listId,</span><br><span class="line">        <span class="attr">$or</span>: [&#123;<span class="attr">userId</span>: &#123;<span class="attr">$exists</span>: <span class="literal">false</span>&#125;&#125;, &#123;userId&#125;]</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We only need the _id field in this query, since it's only</span></span><br><span class="line">      <span class="comment">// used to drive the child queries to get the todos</span></span><br><span class="line">      <span class="keyword">const</span> options = &#123;</span><br><span class="line">        <span class="attr">fields</span>: &#123; <span class="attr">_id</span>: <span class="number">1</span> &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Lists.find(query, options);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      find(list) &#123;</span><br><span class="line">        <span class="keyword">return</span> Todos.find(&#123; <span class="attr">listId</span>: list._id &#125;, &#123; <span class="attr">fields</span>: Todos.publicFields &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>In this example, we write a complicated query to make sure that we only ever find a list if we are allowed to see it, then, once per list we find (which can be one or zero times depending on access), we publish the todos for that list. Publish Composite takes care of stopping and starting the dependent cursors if the list stops matching the original query or otherwise.</p>
<h3 id="complex-auth">Complex authorization</h3>

<p>We can also use <code>publish-composite</code> to perform complex authorization in publications. For instance, consider if we had a <code>Todos.admin.inList</code> publication that allowed an admin to bypass default publication’s security for users with an <code>admin</code> flag set.</p>
<p>We might want to write:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'Todos.admin.inList'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">&#123; listId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">listId</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;</span><br><span class="line">  &#125;).validate(&#123; listId &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> user = Meteor.users.findOne(<span class="keyword">this</span>.userId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (user &amp;&amp; user.admin) &#123;</span><br><span class="line">    <span class="comment">// We don't need to worry about the list.userId changing this time</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      Lists.find(listId),</span><br><span class="line">      Todos.find(&#123;listId&#125;)</span><br><span class="line">    ];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ready();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>However, due to the same reasons discussed above, the publication <em>will not re-run</em> if the user’s <code>admin</code> status changes. If this is something that is likely to happen and reactive changes are needed, then we’ll need to make the publication reactive. We can do this via the same technique as above however:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publishComposite(<span class="string">'Todos.admin.inList'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">listId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">listId</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;</span><br><span class="line">  &#125;).validate(&#123; listId &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> userId = <span class="keyword">this</span>.userId;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    find() &#123;</span><br><span class="line">      <span class="keyword">return</span> Meteor.users.find(&#123;<span class="attr">_id</span>: userId, <span class="attr">admin</span>: <span class="literal">true</span>&#125;, &#123;<span class="attr">fields</span>: &#123;<span class="attr">admin</span>: <span class="number">1</span>&#125;&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      find(user) &#123;</span><br><span class="line">        <span class="comment">// We don't need to worry about the list.userId changing this time</span></span><br><span class="line">        <span class="keyword">return</span> Lists.find(listId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      find(user) &#123;</span><br><span class="line">        <span class="keyword">return</span> Todos.find(&#123;listId&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Note that we explicitly set the <code>Meteor.users</code> query fields, as <code>publish-composite</code> publishes all of the returned cursors to the client and re-runs the child computations whenever the cursor changes.</p>
<p>Limiting the results serves a double purpose: it both prevents sensitive fields from being disclosed to the client and limits recomputation to the relevant fields only (namely, the <code>admin</code> field).</p>
<h3 id="custom-publication">Custom publications with the low level API</h3>

<p>In all of our examples so far (outside of using<code>Meteor.publishComposite()</code>) we’ve returned a cursor from our <code>Meteor.publish()</code> handlers. Doing this ensures Meteor takes care of the job of keeping the contents of that cursor in sync between the server and the client. However, there’s another API you can use for publish functions which is closer to the way the underlying Distributed Data Protocol (DDP) works.</p>
<p>DDP uses three main messages to communicate changes in the data for a publication: the <code>added</code>, <code>changed</code> and <code>removed</code> messages. So, we can similarly do the same for a publication:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'custom-publication'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We can add documents one at a time</span></span><br><span class="line">  <span class="keyword">this</span>.added(<span class="string">'collection-name'</span>, <span class="string">'id'</span>, &#123;<span class="attr">field</span>: <span class="string">'values'</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can call ready to indicate to the client that the initial document sent has been sent</span></span><br><span class="line">  <span class="keyword">this</span>.ready();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We may respond to some 3rd party event and want to send notifications</span></span><br><span class="line">  Meteor.setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// If we want to modify a document that we've already added</span></span><br><span class="line">    <span class="keyword">this</span>.changed(<span class="string">'collection-name'</span>, <span class="string">'id'</span>, &#123;<span class="attr">field</span>: <span class="string">'new-value'</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or if we don't want the client to see it any more</span></span><br><span class="line">    <span class="keyword">this</span>.removed(<span class="string">'collection-name'</span>, <span class="string">'id'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It's very important to clean up things in the subscription's onStop handler</span></span><br><span class="line">  <span class="keyword">this</span>.onStop(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Perhaps kill the connection with the 3rd party server</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>From the client’s perspective, data published like this doesn’t look any different—there’s actually no way for the client to know the difference as the DDP messages are the same. So even if you are connecting to, and mirroring, some esoteric data source, on the client it’ll appear like any other Mongo collection.</p>
<p>One point to be aware of is that if you allow the user to <em>modify</em> data in the “pseudo-collection” you are publishing in this fashion, you’ll want to be sure to re-publish the modifications to them via the publication, to achieve an optimistic user experience.</p>
<h3 id="lifecycle">Subscription lifecycle</h3>

<p>Although you can use publications and subscriptions in Meteor via an intuitive understanding, sometimes it’s useful to know exactly what happens under the hood when you subscribe to data.</p>
<p>Suppose you have a simple publication of the following form:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Meteor.publish(<span class="string">'Posts.all'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Posts.find(&#123;&#125;, &#123;<span class="attr">limit</span>: <span class="number">10</span>&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Then when a client calls <code>Meteor.subscribe(&#39;Posts.all&#39;)</code> the following things happen inside Meteor:</p>
<ol>
<li><p>The client sends a <code>sub</code> message with the name of the subscription over DDP.</p>
</li>
<li><p>The server starts up the subscription by running the publication handler function.</p>
</li>
<li><p>The publication handler identifies that the return value is a cursor. This enables a convenient mode for publishing cursors.</p>
</li>
<li><p>The server sets up a query observer on that cursor, unless such an observer already exists on the server (for any user), in which case that observer is re-used.</p>
</li>
<li><p>The observer fetches the current set of documents matching the cursor, and passes them back to the subscription (via the <code>this.added()</code> callback).</p>
</li>
<li><p>The subscription passes the added documents to the subscribing client’s connection <em>mergebox</em>, which is an on-server cache of the documents that have been published to this particular client. Each document is merged with any existing version of the document that the client knows about, and an <code>added</code> (if the document is new to the client) or <code>changed</code> (if it is known but this subscription is adding or changing fields) DDP message is sent.</p>
<p>Note that the mergebox operates at the level of top-level fields, so if two subscriptions publish nested fields (e.g. sub1 publishes <code>doc.a.b = 7</code> and sub2 publishes <code>doc.a.c = 8</code>), then the “merged” document might not look as you expect (in this case <code>doc.a = {c: 8}</code>, if sub2 happens second).</p>
</li>
<li><p>The publication calls the <code>.ready()</code> callback, which sends the DDP <code>ready</code> message to the client. The subscription handle on the client is marked as ready.</p>
</li>
<li><p>The observer observes the query. Typically, it <a href="https://github.com/meteor/meteor/wiki/Oplog-Observe-Driver" target="_blank" rel="external">uses MongoDB’s Oplog</a> to notice changes that affect the query. If it sees a relevant change, like a new matching document or a change in a field on a matching document, it calls into the subscription (via <code>.added()</code>, <code>.changed()</code> or <code>.removed()</code>), which again sends the changes to the mergebox, and then to the client via DDP.</p>
</li>
</ol>
<p>This continues until the client <a href="#stopping-subscriptions">stops</a> the subscription, triggering the following behavior:</p>
<ol>
<li><p>The client sends the <code>unsub</code> DDP message.</p>
</li>
<li><p>The server stops its internal subscription object, triggering the following effects:</p>
</li>
<li><p>Any <code>this.onStop()</code> callbacks setup by the publish handler run. In this case, it is a single automatic callback setup when returning a cursor from the handler, which stops the query observer and cleans it up if necessary.</p>
</li>
<li><p>All documents tracked by this subscription are removed from the mergebox, which may or may not mean they are also removed from the client.</p>
</li>
<li><p>The <code>nosub</code> message is sent to the client to indicate that the subscription has stopped.</p>
</li>
</ol>
<h2 id="rest-interop">Working with REST APIs</h2>

<p>Publications and subscriptions are the primary way of dealing with data in Meteor’s DDP protocol, but lots of data sources use the popular REST protocol for their API. It’s useful to be able to convert between the two.</p>
<h3 id="loading-from-rest">Loading data from a REST endpoint with a publication</h3>

<p>As a concrete example of using the <a href="#custom-publication">low-level API</a>, consider the situation where you have some 3rd party REST endpoint which provides a changing set of data that’s valuable to your users. How do you make that data available?</p>
<p>One option would be to provide a Method that simply proxies through to the endpoint, for which it’s the client’s responsibility to poll and deal with the changing data as it comes in. So then it’s the clients problem to deal with keeping a local data cache of the data, updating the UI when changes happen, etc. Although this is possible (you could use a Local Collection to store the polled data, for instance), it’s simpler, and more natural to create a publication that does this polling for the client.</p>
<p>A pattern for turning a polled REST endpoint looks something like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> POLL_INTERVAL = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">Meteor.publish(<span class="string">'polled-publication'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> publishedKeys = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> poll = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Let's assume the data comes back as an array of JSON documents, with an _id field, for simplicity</span></span><br><span class="line">    <span class="keyword">const</span> data = HTTP.get(REST_URL, REST_OPTIONS);</span><br><span class="line"></span><br><span class="line">    data.forEach(<span class="function">(<span class="params">doc</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (publishedKeys[doc._id]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.changed(COLLECTION_NAME, doc._id, doc);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        publishedKeys[doc._id] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.added(COLLECTION_NAME, doc._id, doc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  poll();</span><br><span class="line">  <span class="keyword">this</span>.ready();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> interval = Meteor.setInterval(poll, POLL_INTERVAL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.onStop(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    Meteor.clearInterval(interval);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Things can get more complicated; for instance you may want to deal with documents being removed, or share the work of polling between multiple users (in a case where the data being polled isn’t private to that user), rather than doing the exact same poll for each interested user.</p>
<h3 id="publications-as-rest">Accessing a publication as a REST endpoint</h3>

<p>The opposite scenario occurs when you want to publish data to be consumed by a 3rd party, typically over REST. If the data we want to publish is the same as what we already publish via a publication, then we can use the <a href="https://atmospherejs.com/simple/rest" target="_blank" rel="external">simple:rest</a> package to do this really easily.</p>
<p>In the Todos example app, we have done this, and you can now access our publications over HTTP:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:3000/publications/lists.public</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Lists"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"_id"</span>: <span class="string">"rBt5iZQnDpRxypu68"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"Meteor Principles"</span>,</span><br><span class="line">      <span class="string">"incompleteCount"</span>: 7</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"_id"</span>: <span class="string">"Qzc2FjjcfzDy3GdsG"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"Languages"</span>,</span><br><span class="line">      <span class="string">"incompleteCount"</span>: 9</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"_id"</span>: <span class="string">"TXfWkSkoMy6NByGNL"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"Favorite Scientists"</span>,</span><br><span class="line">      <span class="string">"incompleteCount"</span>: 6</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can also access authenticated publications (such as <code>lists.private</code>). Suppose we’ve signed up (via the web UI) as <code>user@example.com</code>, with the password <code>password</code>, and created a private list. Then we can access it as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, we need to "login" on the commandline to get an access token</span></span><br><span class="line">$ curl localhost:3000/users/login  -H <span class="string">"Content-Type: application/json"</span> --data <span class="string">'&#123;"email": "user@example.com", "password": "password"&#125;'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"wq5oLMLi2KMHy5rR6"</span>,</span><br><span class="line">  <span class="string">"token"</span>: <span class="string">"6PN4EIlwxuVua9PFoaImEP9qzysY64zM6AfpBJCE6bs"</span>,</span><br><span class="line">  <span class="string">"tokenExpires"</span>: <span class="string">"2016-02-21T02:27:19.425Z"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, we can make an authenticated API call</span></span><br><span class="line">$ curl localhost:3000/publications/lists.private -H <span class="string">"Authorization: Bearer 6PN4EIlwxuVua9PFoaImEP9qzysY64zM6AfpBJCE6bs"</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Lists"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"_id"</span>: <span class="string">"92XAn3rWhjmPEga4P"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"My Private List"</span>,</span><br><span class="line">      <span class="string">"incompleteCount"</span>: 5,</span><br><span class="line">      <span class="string">"userId"</span>: <span class="string">"wq5oLMLi2KMHy5rR6"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>
  </div>

  <div class="pagination">
    <div class="content-wrapper">
      
      
        <a class="link primary prev"
          href="collections.html">
          <span class="icon-arrow-left-alt"></span>
          <span class="subtitle-pagination">Previous</span>
          Collections and Schemas
        </a>
      
      
        <a class="link primary next"
          href="methods.html">
          <span class="subtitle-pagination">Next</span>
          Methods
          <span class="icon-arrow-right-alt"></span>
        </a>
      
    </div>
  </div>

  <div class="github">
    <a class="link tertiary " href="https://github.com/meteor/guide/tree/master/content/data-loading.md" target="_blank">
      <span class="icon-github"></span>Edit on GitHub</a>
  </div>

  
    <div class="discourse-comments-wrapper content-wrapper">
      <div id='discourse-comments'></div>
    </div>

    <script type="text/javascript">
      DiscourseEmbed = { discourseUrl: 'https://forums.meteor.com/',
                         topicId: 19661 };

      (function() {
        var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
        d.src = DiscourseEmbed.discourseUrl + 'javascripts/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
      })();
    </script>
  
</div>

    <script src="/script/smooth-scroll.min.js"></script>
    <script src="/script/main.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/2.1.8/docsearch.min.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

    <script>
      // nectar ninja
      (function(){
        var handle = '@meteorjs';
        var a = document.createElement('script');
        var m = document.getElementsByTagName('script')[0];
        a.async = 1;
        a.src = 'https://nectar.ninja/api/v1/' + handle.slice(1);
        m.parentNode.insertBefore(a, m);
      })();

     
      
        // Segment Tracking
        !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
        analytics.load("zQx6cQifkTU79E3L0XAnmrOXP2A5bC6r");
        analytics.page()
        }}();
      

      // search box
      

        ['desktop'].forEach(function(type) {
          var search = docsearch({
            apiKey: 'bdf6b09d12024f6bae3631a0dfdd4a7f',
            indexName: 'meteor_api_guide',
            inputSelector: '#' + type + '-search-input',
            autocompleteOptions: {
              dropdownMenuContainer: '.wrapper-' + type + '-search-results',
              debug: true
            },
            algoliaOptions: {
              hitsPerPage: 20
            }
          }).autocomplete;

          var sidebar = document.querySelector('.sidebar-content');
          search.on('autocomplete:opened', function() {
            sidebar.classList.add('searching');
          });
          search.on('autocomplete:closed', function() {
            sidebar.classList.remove('searching');
          });
          search.on('autocomplete:updated', function() {
            if (search.val() === '') {
              search.autocomplete.close();
            }
          });
        });
      

      
        var REDIRECTS = {
  "/using-packages.html": "atmosphere-vs-npm.html",
  "/using-packages.html#npm": "using-npm-packages.html",
  "/using-packages.html#client-npm": "using-npm-packages.html#client-npm",
  "/using-packages.html#installing-npm": "using-npm-packages.html#installing-npm",
  "/using-packages.html#using-npm": "using-npm-packages.html#using-npm",
  "/using-packages.html#npm-styles": "using-npm-packages.html#npm-styles",
  "/using-packages.html#npm-shrinkwrap": "using-npm-packages.html#npm-shrinkwrap",
  "/using-packages.html#atmosphere": "using-atmosphere-packages.html",
  "/using-packages.html#atmosphere-searching": "using-atmosphere-packages.html#atmosphere-searching",
  "/using-packages.html#atmosphere-naming": "using-atmosphere-packages.html#atmosphere-naming",
  "/using-packages.html#installing-atmosphere": "using-atmosphere-packages.html#installing-atmosphere",
  "/using-packages.html#using-atmosphere": "using-atmosphere-packages.html#using-atmosphere",
  "/using-packages.html#importing-atmosphere-styles": "using-atmosphere-packages.html#importing-atmosphere-styles",
  "/using-packages.html#peer-npm-dependencies": "using-atmosphere-packages.html#peer-npm-dependencies",
  "/using-packages.html#package-namespacing": "using-atmosphere-packages.html#package-namespacing",
  "/using-packages.html#async-callbacks": "using-npm-packages.html#async-callbacks",
  "/using-packages.html#bind-environment": "using-npm-packages.html#bind-environment",
  "/using-packages.html#wrap-async": "using-npm-packages.html#wrap-async",
  "/using-packages.html#promises": "using-npm-packages.html#promises",
  "/using-packages.html#overriding-packages": "writing-npm-packages.html#overriding-npm-packages",
  "/using-packages.html#npm-overriding": "writing-npm-packages.html#overriding-npm-packages",
  "/using-packages.html#atmosphere-overriding": "writing-atmosphere-packages.html#overriding-atmosphere-packages",
  "/using-packages.html#npm-shrinkpack": "using-npm-packages.html#npm-shrinkpack",
  "/writing-packages.html": "writing-atmosphere-packages.html",
  "/writing-packages.html#npm-vs-atmosphere": "atmosphere-vs-npm.html",
  "/writing-packages.html#creating-npm": "writing-npm-packages.html",
  "/writing-packages.html#including-in-app": "writing-npm-packages.html#including-in-app",
  "/writing-packages.html#publishing-npm": "writing--packages.html#publishing-npm",
  "/writing-packages.html#creating": "writing-atmosphere-packages.html",
  "/writing-packages.html#adding-files": "writing-atmosphere-packages.html#adding-files",
  "/writing-packages.html#adding-javascript": "writing-atmosphere-packages.html#adding-javascript",
  "/writing-packages.html#adding-css": "writing-atmosphere-packages.html#adding-css",
  "/writing-packages.html#adding-style": "writing-atmosphere-packages.html#adding-style",
  "/writing-packages.html#adding-assests": "writing-atmosphere-packages.html#adding-assets",
  "/writing-packages.html#exporting": "writing-atmosphere-packages.html#exporting",
  "/writing-packages.html#dependencies": "writing-atmosphere-packages.html#dependencies",
  "/writing-packages.html#atmosphere-dependencies": "writing-atmosphere--packages.html#atmosphere-dependencies",
  "/writing-packages.html#meteor-version-dependencies": "writing-atmosphere-packages.html#meteor-version-dependencies",
  "/writing-packages.html#version-constraints": "writing-atmosphere-packages.html#version-constraints",
  "/writing-packages.html#npm-dependencies": "writing-atmosphere-packages.html#npm-dependencies",
  "/writing-packages.html#peer-npm-dependencies": "writing-atmosphere-packages.html#peer-npm-dependencies",
  "/writing-packages.html#cordova-plugins": "writing-atmosphere-packages.html#cordova-plugins",
  "/writing-packages.html#testing": "writing-atmosphere-packages.html#testing",
  "/writing-packages.html#testing-with-peer-dependencies": "writing-atmosphere-packages.html#testing-with-peer-dependencies",
  "/writing-packages.html#local-vs-published": "writing-atmosphere-packages.html#local-vs-published",
  "/writing-packages.html#build-plugins": "build-tool.html#build-plugins",
  "/writing-packages.html#types-of-build-plugins": "build-tool.html#types-of-build-plugins",
  "/writing-packages.html#writing-build-plugins": "build-tool.html#writing-build-plugins",
  "/writing-packages.html#caching-build-plugins": "build-tool.html#caching-build-plugins",
  "/testing.html#simple-unit-test": "testing.html#simple-blaze-unit-test"
};

        function redirect() {
          // Support redirects of the form /path#hash
          var locationKey = location.pathname + location.hash;
          if (REDIRECTS[locationKey]) {
            location.replace(location.origin + '/' + REDIRECTS[locationKey]);
          }

          // Support redirects of the form #hash (works for any path)
          var hashKey = location.hash;
          if (REDIRECTS[hashKey]) {
            location.replace(location.origin + '/' + REDIRECTS[hashKey]);
          }
        }

        // Redirect now
        redirect();

        // Redirect on hash change
        window.onhashchange = redirect;
      
    </script>
  </body>
</html>
