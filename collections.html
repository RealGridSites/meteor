<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <!-- Basic -->
    <title>Collections and Schemas | Meteor Guide</title>
    <meta name="description" content="How to define, use, and maintain MongoDB collections in Meteor.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../images/favicon.png" sizes="16x16 32x32 64x64">

    <!-- Social -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="http://guide.meteor.com">
    <meta property="og:title" content="Collections and Schemas | Meteor Guide">
    <meta property="og:description" content="How to define, use, and maintain MongoDB collections in Meteor.">
    <meta property="og:image" content="">
    <meta name="twitter:card" content="summary_image_large">
    <meta name="twitter:site" content="@meteor">
    <meta name="twitter:title" content="Collections and Schemas | Meteor Guide">
    <meta name="twitter:description" content="How to define, use, and maintain MongoDB collections in Meteor.">
    <meta name="twitter:image" content="">

    <!-- Misc -->
    <meta name="google-site-verification" content="" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,200,300italic,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/style/style.css">
  </head>
  <body class="">
    

<div class="nav dark">
  <div class="nav-group">
    <div class="nav-item show-mobile">
      <span class="js-sidebar-toggle ">
        <span class="icon-menu"></span>
      </span>
    </div>
    <div class="nav-item">
      <a class="logo-wrapper" href="http://www.meteor.com/developers" title="Meteor Developers Developers"  >
        <img src="../images/logo-coralspace-left.svg" alt="Meteor Developers" class="logo"/>
        <span>Developers</span>
      </a>
    </div>
  </div>

  <div class="nav-group right">
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="http://www.meteor.com/tutorials" target=_new >
          <span>Tutorials</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop active ">
        <a class="link" href="http://guide.meteor.com"  >
          <span>Guide</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="http://docs.meteor.com"  >
          <span>API Docs</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="https://forums.meteor.com/" target=_new >
          <span>Forums</span>
        </a>
      </div>
    
  </div>
</div>

<div class="sidebar">
  <div class="panel">
    <div class="panel-item">
      <a class="" href="http://www.meteor.com/developers" title="Meteor Developers"  >
        <span>Meteor Developers Developers</span>
      </a>
    </div>
    
      <div class="panel-item "">
        <a class="" href="http://www.meteor.com/tutorials" target=_new >
          <span>Tutorials</span>
        </a>
      </div>
    
      <div class="panel-item active"">
        <a class="" href="http://guide.meteor.com"  >
          <span>Guide</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://docs.meteor.com"  >
          <span>API Docs</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="https://forums.meteor.com/" target=_new >
          <span>Forums</span>
        </a>
      </div>
    
  </div>

  <div class="sidebar-content">
    <div class="topcap">
      <span class="title-sidebar">Meteor Guide</span>
      
        <span class="select version-sidebar nochrome">
          <select class="version-select">
            
              <option value="v1.4">1.4</option>
            
              <option value="v1.3">1.3</option>
            
              <option value="v1.2">1.2</option>
            
          </select>
        </span>
      
    </div>

    
    <div class="wrapper-search">
      <div class="input-symbol small round">
        <input type="text" placeholder="Search The Official Guide" id="desktop-search-input" />
        <span class="icon-search"></span>
      </div>
      <div class="wrapper-desktop-search-results"></div>
    </div>

    

    <ul class="toc">
      
        <li>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="index.html" class="sidebar-link ">
                  <span>Introduction</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="code-style.html" class="sidebar-link ">
                  <span>Code Style</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="structure.html" class="sidebar-link ">
                  <span>Application Structure</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="1.4-migration.html" class="sidebar-link ">
                  <span>Migrating to Meteor 1.4</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="1.3-migration.html" class="sidebar-link ">
                  <span>Migrating to Meteor 1.3</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Data</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc  current">
                <a href="" class="sidebar-link  current">
                  <span>Collections and Schemas</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="data-loading.html" class="sidebar-link ">
                  <span>Publications and Data Loading</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="methods.html" class="sidebar-link ">
                  <span>Methods</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="accounts.html" class="sidebar-link ">
                  <span>Users and Accounts</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="testing.html" class="sidebar-link ">
                  <span>Testing</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">View</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="routing.html" class="sidebar-link ">
                  <span>URLs and Routing</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="ui-ux.html" class="sidebar-link ">
                  <span>User Interfaces</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="blaze.html" class="sidebar-link ">
                  <span>Blaze</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="react.html" class="sidebar-link ">
                  <span>React</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="angular.html" class="sidebar-link ">
                  <span>Angular</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Build</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="atmosphere-vs-npm.html" class="sidebar-link ">
                  <span>Atmosphere vs. npm</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="using-atmosphere-packages.html" class="sidebar-link ">
                  <span>Using Atmosphere Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="writing-atmosphere-packages.html" class="sidebar-link ">
                  <span>Writing Atmosphere Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="using-npm-packages.html" class="sidebar-link ">
                  <span>Using npm Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="writing-npm-packages.html" class="sidebar-link ">
                  <span>Writing npm Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="mobile.html" class="sidebar-link ">
                  <span>Mobile</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="build-tool.html" class="sidebar-link ">
                  <span>Build System</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Production</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="security.html" class="sidebar-link ">
                  <span>Security</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="deployment.html" class="sidebar-link ">
                  <span>Deployment and Monitoring</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Meta</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="CONTRIBUTING.html" class="sidebar-link ">
                  <span>Contribution Guidelines</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="CHANGELOG.html" class="sidebar-link ">
                  <span>Changelog</span>
                </a>
              </li>
            
          </ul>
        </li>
      
    </ul>
  </div>
</div>

<div class="content">
  <div class="content-wrapper">
    <div class="header-content">
      <h1 class="title-page">Collections and Schemas</h1>
      
        <div class="subtitle-page">How to define, use, and maintain MongoDB collections in Meteor.</div>
      

      <div class="page-actions">
        <div class="actions-group">
          <a class="btn tertiary small round lowercase" href="https://github.com/meteor/guide/tree/master/content/collections.md" target="_blank"><span class="icon-github"></span> <span>Edit on GitHub</span></a>
          
            <a class="btn tertiary small round lowercase" href="https://forums.meteor.com/t/19660"><span class="icon-comment"></span> <span>Discuss</span></a>
          
        </div>
      </div>
    </div>

    <div class="document-formatting">
      <p>After reading this guide, you’ll know:<br>이 가이드를 읽으면 다음을 알 수 있습니다:</p>
<ol>
<li>The different types of MongoDB collections in Meteor, and how to use them.</li>
<li>How to define a schema for a collection to control its content.</li>
<li>What to consider when defining your collection’s schema.</li>
<li>How to enforce the schema when writing to a collection.</li>
<li>How to carefully change the schema of your collection.</li>
<li>How to deal with associations between records.</li>
</ol>
<ol>
<li>Meteor에서 MongoDB 컬렉션의 다른 유형과 사용 방법.</li>
<li>콜렉션에 대한 스키마를 정의하여 컨텐츠를 제어하는 ​​방법.</li>
<li>컬렉션의 스키마를 정의 할 때 고려해야 할 사항.</li>
<li>컬렉션에 쓸 때 스키마를 적용하는 방법.</li>
<li>신중하게 컬렉션의 스키마를 변경하는 방법.</li>
<li>레코드 간의 연결을 처리하는 방법.</li>
</ol>
<h2 id="mongo-collections">MongoDB collections in Meteor</h2>

<p>At its core, a web application offers its users a view into, and a way to modify, a persistent set of data. Whether managing a list of todos, or ordering a car to pick you up, you are interacting with a permanent but constantly changing data layer.</p>
<p>웹 응용 프로그램의 핵심은 영구적 인 데이터 집합에 대한보기와 수정 방법을 사용자에게 제공하는 것입니다. 할 일 목록을 관리하거나 자동차를 데리러 오더라도 영구적이지만 끊임없이 변화하는 데이터 계층과 상호 작용합니다.</p>
<p>In Meteor, that data layer is typically stored in MongoDB. A set of related data in MongoDB is referred to as a “collection”. In Meteor you access MongoDB through <a href="http://docs.meteor.com/api/collections.html#Mongo-Collection" target="_blank" rel="external">collections</a>, making them the primary persistence mechanism for your app data.</p>
<p>Meteor에서는 일반적으로 해당 데이터 계층이 MongoDB에 저장됩니다. MongoDB에있는 관련 데이터 세트를 “콜렉션”이라고합니다. Meteor에서는 <a href="http://docs.meteor.com/api/collections.html#Mongo-Collection" target="_blank" rel="external">collections</a>을 통해 MongoDB에 액세스하여 앱 데이터의 기본 지속성 메커니즘으로 사용합니다.</p>
<p>However, collections are a lot more than a way to save and retrieve data. They also provide the core of the interactive, connected user experience that users expect from the best applications. Meteor makes this user experience easy to implement.</p>
<p>그러나 콜렉션은 데이터를 저장하고 검색하는 방법 이상입니다. 또한 사용자가 최상의 응용 프로그램에서 기대하는 대화 형 사용자 경험의 핵심을 제공합니다. Meteor를 사용하면이 사용자 환경을 쉽게 구현할 수 있습니다.</p>
<p>In this article, we’ll look closely at how collections work in various places in the framework, and how to get the most out of them.</p>
<p>이 기사에서는 프레임 워크의 다양한 위치에서 컬렉션이 작동하는 방식과 컬렉션을 최대한 활용하는 방법을 자세히 살펴볼 것입니다.</p>
<h3 id="server-collections">Server-side collections</h3>

<p>When you create a collection on the server:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Todos = <span class="keyword">new</span> Mongo.Collection(<span class="string">'todos'</span>);</span><br></pre></td></tr></table></figure>
<p>You are creating a collection within MongoDB, and an interface to that collection to be used on the server. It’s a fairly straightforward layer on top of the underlying Node MongoDB driver, but with a synchronous API:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This line won't complete until the insert is done</span></span><br><span class="line">Todos.insert(&#123;<span class="attr">_id</span>: <span class="string">'my-todo'</span>&#125;);</span><br><span class="line"><span class="comment">// So this line will return something</span></span><br><span class="line"><span class="keyword">const</span> todo = Todos.findOne(&#123;<span class="attr">_id</span>: <span class="string">'my-todo'</span>&#125;);</span><br><span class="line"><span class="comment">// Look ma, no callbacks!</span></span><br><span class="line"><span class="built_in">console</span>.log(todo);</span><br></pre></td></tr></table></figure>
<h3 id="client-collections">Client-side collections</h3>

<p>On the client, when you write the same line:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Todos = <span class="keyword">new</span> Mongo.Collection(<span class="string">'todos'</span>);</span><br></pre></td></tr></table></figure>
<p>It does something totally different!</p>
<p>On the client, there is no direct connection to the MongoDB database, and in fact a synchronous API to it is not possible (nor probably what you want). Instead, on the client, a collection is a client side <em>cache</em> of the database. This is achieved thanks to the <a href="https://www.meteor.com/mini-databases" target="_blank" rel="external">Minimongo</a> library—an in-memory, all JS, implementation of the MongoDB API. What this means is that on the client, when you write:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This line is changing an in-memory Minimongo data structure</span></span><br><span class="line">Todos.insert(&#123;<span class="attr">_id</span>: <span class="string">'my-todo'</span>&#125;);</span><br><span class="line"><span class="comment">// And this line is querying it</span></span><br><span class="line"><span class="keyword">const</span> todo = Todos.findOne(&#123;<span class="attr">_id</span>: <span class="string">'my-todo'</span>&#125;);</span><br><span class="line"><span class="comment">// So this happens right away!</span></span><br><span class="line"><span class="built_in">console</span>.log(todo);</span><br></pre></td></tr></table></figure>
<p>The way that you move data from the server (and MongoDB-backed) collection into the client (in-memory) collection is the subject of the <a href="data-loading.html">data loading article</a>. Generally speaking, you <em>subscribe</em> to a <em>publication</em>, which pushes data from the server to the client. Usually, you can assume that the client contains an up-to-date copy of some subset of the full MongoDB collection.</p>
<p>To write data back to the server, you use a <em>Method</em>, the subject of the <a href="methods.html">methods article</a>.</p>
<h3 id="local-collections">Local collections</h3>

<p>There is a third way to use a collection in Meteor. On the client or server, if you create a collection but pass <code>null</code> instead of a name:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectedTodos = <span class="keyword">new</span> Mongo.Collection(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>This creates a <em>local collection</em>. This is a Minimongo collection that has no database connection (ordinarily a named collection would either be directly connected to the database on the server, or via a subscription on the client).</p>
<p>A local collection is a convenient way to use the full power of the Minimongo library for in-memory storage. For instance, you might use it instead of a simple array if you need to execute complex queries over your data. Or you may want to take advantage of its <em>reactivity</em> on the client to drive some UI in a way that feels natural in Meteor.</p>
<h2 id="schemas">Defining a schema</h2>

<p>Although MongoDB is a schema-less database, which allows maximum flexibility in data structuring, it is generally good practice to use a schema to constrain the contents of your collection to conform to a known format. If you don’t, then you tend to end up needing to write defensive code to check and confirm the structure of your data as it <em>comes out</em> of the database, instead of when it <em>goes into</em> the database. As in most things, you tend to <em>read data more often than you write it</em>, and so it’s usually easier, and less buggy to use a schema when writing.</p>
<p>In Meteor, the pre-eminent schema package is <a href="https://atmospherejs.com/aldeed/simple-schema" target="_blank" rel="external">aldeed:simple-schema</a>. It’s an expressive, MongoDB based schema that’s used to insert and update documents. Another alternative is <a href="https://atmospherejs.com/jagi/astronomy" target="_blank" rel="external">jagi:astronomy</a> which is a full Object Model (OM) layer offering schema definition, server/client side validators, object methods and event handlers.</p>
<p>Let’s assume that we have a <code>Lists</code> collection.  To define a schema for this collection using <code>simple-schema</code>, you can simply create a new instance of the <code>SimpleSchema</code> class and attach it to the <code>Lists</code> object:</p>
<p>MongoDB는 스키마가없는 데이터베이스이지만 데이터 구조화의 유연성을 극대화 할 수 있지만 일반적으로 스키마를 사용하여 컬렉션의 내용을 알려진 형식에 맞게 제한하는 것이 좋습니다. 그렇지 않으면 데이터베이스에 들어갈 때가 아니라 데이터베이스에서 나오는 데이터 구조를 확인하고 확인하기 위해 방어 코드를 작성해야합니다. 대부분의 경우와 마찬가지로 작성하는 것보다 더 자주 데이터를 읽는 경향이 있으므로 일반적으로 작성시 스키마를 사용하는 것이 더 쉽고 버그가 적습니다.</p>
<p>Meteor에서, 저명한 스키마 패키지는 <a href="https://atmospherejs.com/aldeed/simple-schema" target="_blank" rel="external">aldeed:simple-schema</a>입니다. 이는 문서를 삽입하고 업데이트하는 데 사용되는 표현형 MongoDB 기반 스키마입니다. 또 다른 대안은 <a href="https://atmospherejs.com/jagi/astronomy" target="_blank" rel="external">jagi:astronomy</a>. 스키마 정의, 서버 / 클라이언트 측 유효성 검사기, 객체 메서드 및 이벤트 처리기를 제공하는 전체 객체 모델 (OM) 계층입니다.</p>
<p>목록 컬렉션이 있다고 가정 해 보겠습니다. 간단한 스키마를 사용하여이 컬렉션에 대한 스키마를 정의하려면 SimpleSchema 클래스의 새 인스턴스를 만들고이를 Lists 개체에 첨부하기 만하면됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lists.schema = <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">  <span class="attr">incompleteCount</span>: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">defaultValue</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  <span class="attr">userId</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">regEx</span>: SimpleSchema.RegEx.Id, <span class="attr">optional</span>: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This example from the Todos app defines a schema with a few simple rules:</p>
<p>Todos 앱의이 예는 몇 가지 간단한 규칙이있는 스키마를 정의합니다.</p>
<ol>
<li>We specify that the <code>name</code> field of a list is required and must be a string.</li>
<li>We specify the <code>incompleteCount</code> is a number, which on insertion is set to <code>0</code> if not otherwise specified.</li>
<li>We specify that the <code>userId</code>, which is optional, must be a string that looks like the ID of a user document.</li>
</ol>
<ol>
<li>목록의 이름 필드가 필요하며 문자열이어야한다고 지정합니다.</li>
<li>incompleteCount를 숫자로 지정합니다.이 값은 별도로 지정하지 않으면 삽입시 0으로 설정됩니다.</li>
<li>선택적인 userId는 사용자 문서의 ID와 같은 형식의 문자열이어야한다고 지정합니다.</li>
</ol>
<p>We attach the schema to the namespace of <code>Lists</code> directly, which allows us to check objects against this schema directly whenever we want, such as in a form or <a href="methods.html">Method</a>. In the <a href="#schemas-on-write">next section</a> we’ll see how to use this schema automatically when writing to the collection.</p>
<p>You can see that with relatively little code we’ve managed to restrict the format of a list significantly. You can read more about more complex things that can be done with schemas in the <a href="http://atmospherejs.com/aldeed/simple-schema" target="_blank" rel="external">Simple Schema docs</a>.</p>
<p>Lists의 네임 스페이스에 스키마를 직접 연결합니다. 이렇게하면 폼이나 메서드와 같이 원할 때마다이 스키마에 대해 개체를 직접 확인할 수 있습니다. 다음 섹션에서는 컬렉션에 쓸 때이 스키마를 자동으로 사용하는 방법을 살펴 보겠습니다. 상대적으로 적은 코드로 목록의 형식을 상당히 제한 할 수 있다는 것을 알 수 있습니다. Simple Schema 문서에서 스키마를 사용하여 수행 할 수있는보다 복잡한 작업에 대한 자세한 내용을 볼 수 있습니다.</p>
<h3 id="validating-schemas">Validating against a schema</h3>

<p>Now we have a schema, how do we use it?</p>
<p>It’s pretty straightforward to validate a document with a schema. We can write:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'My list'</span>,</span><br><span class="line">  <span class="attr">incompleteCount</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Lists.schema.validate(list);</span><br></pre></td></tr></table></figure>
<p>In this case, as the list is valid according to the schema, the <code>validate()</code> line will run without problems. If however, we wrote:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'My list'</span>,</span><br><span class="line">  <span class="attr">incompleteCount</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">madeUpField</span>: <span class="string">'this should not be here'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Lists.schema.validate(list);</span><br></pre></td></tr></table></figure>
<p>Then the <code>validate()</code> call will throw a <code>ValidationError</code> which contains details about what is wrong with the <code>list</code> document.</p>
<h3 id="validation-error">The <code>ValidationError</code></h3>

<p>What is a <a href="https://github.com/meteor/validation-error/" target="_blank" rel="external"><code>ValidationError</code></a>? It’s a special error that is used in Meteor to indicate a user-input based error in modifying a collection. Typically, the details on a <code>ValidationError</code> are used to mark up a form with information about what inputs don’t match the schema. In the <a href="methods.html#validation-error">methods article</a>, we’ll see more about how this works.</p>
<h2 id="schema-design">Designing your data schema</h2>

<p>Now that you are familiar with the basic API of Simple Schema, it’s worth considering a few of the constraints of the Meteor data system that can influence the design of your data schema. Although generally speaking you can build a Meteor data schema much like any MongoDB data schema, there are some important details to keep in mind.</p>
<p>The most important consideration is related to the way DDP, Meteor’s data loading protocol, communicates documents over the wire. The key thing to realize is that DDP sends changes to documents at the level of top-level document <em>fields</em>. What this means is that if you have large and complex subfields on document that change often, DDP can send unnecessary changes over the wire.</p>
<p>For instance, in “pure” MongoDB you might design the schema so that each list document had a field called <code>todos</code> which was an array of todo items:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lists.schema = <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">  <span class="attr">todos</span>: &#123;<span class="attr">type</span>: [<span class="built_in">Object</span>]&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The issue with this schema is that due to the DDP behavior just mentioned, each change to <em>any</em> todo item in a list will require sending the <em>entire</em> set of todos for that list over the network. This is because DDP has no concept of “change the <code>text</code> field of the 3rd item in the field called <code>todos</code>“, simply “change the field called <code>todos</code> to a totally new array”.</p>
<h3 id="denormalization">Denormalization and multiple collections</h3>

<p>The implication of the above is that we need to create more collections to contain sub-documents. In the case of the Todos application, we need both a <code>Lists</code> collection and a <code>Todos</code> collection to contain each list’s todo items. Consequently we need to do some things that you’d typically associate with a SQL database, like using foreign keys (<code>todo.listId</code>) to associate one document with another.</p>
<p>In Meteor, it’s often less of a problem doing this than it would be in a typical MongoDB application, as it’s easy to publish overlapping sets of documents (we might need one set of users to render one screen of our app, and an intersecting set for another), which may stay on the client as we move around the application. So in that scenario there is an advantage to separating the subdocuments from the parent.</p>
<p>However, given that MongoDB prior to version 3.2 doesn’t support queries over multiple collections (“joins”), we typically end up having to denormalize some data back onto the parent collection. Denormalization is the practice of storing the same piece of information in the database multiple times (as opposed to a non-redundant “normal” form). MongoDB is a database where denormalizing is encouraged, and thus optimized for this practice.</p>
<p>In the case of the Todos application, as we want to display the number of unfinished todos next to each list, we need to denormalize <code>list.incompleteTodoCount</code>. This is an inconvenience but typically reasonably easy to do as we’ll see in the section on <a href="#abstracting-denormalizers">abstracting denormalizers</a> below.</p>
<p>Another denormalization that this architecture sometimes requires can be from the parent document onto sub-documents. For instance, in Todos, as we enforce privacy of the todo lists via the <code>list.userId</code> attribute, but we publish the todos separately, it might make sense to denormalize <code>todo.userId</code> also. To do this, we’d need to be careful to take the <code>userId</code> from the list when creating the todo, and updating all relevant todos whenever a list’s <code>userId</code> changed.</p>
<h3 id="designing-for-future">Designing for the future</h3>

<p>An application, especially a web application, is rarely finished, and it’s useful to consider potential future changes when designing your data schema. As in most things, it’s rarely a good idea to add fields before you actually need them (often what you anticipate doesn’t actually end up happening, after all).</p>
<p>However, it’s a good idea to think ahead to how the schema may change over time. For instance, you may have a list of strings on a document (perhaps a set of tags). Although it’s tempting to leave them as a subfield on the document (assuming they don’t change much), if there’s a good chance that they’ll end up becoming more complicated in the future (perhaps tags will have a creator, or subtags later on?), then it might be easier in the long run to make a separate collection from the beginning.</p>
<p>The amount of foresight you bake into your schema design will depend on your app’s individual constraints, and will need to be a judgement call on your part.</p>
<h3 id="schemas-on-write">Using schemas on write</h3>

<p>Although there are a variety of ways that you can run data through a Simple Schema before sending it to your collection (for instance you could check a schema in every method call), the simplest and most reliable is to use the <a href="https://atmospherejs.com/aldeed/collection2" target="_blank" rel="external"><code>aldeed:collection2</code></a> package to run every mutator (<code>insert/update/upsert</code> call) through the schema.</p>
<p>To do so, we use <code>attachSchema()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lists.attachSchema(Lists.schema);</span><br></pre></td></tr></table></figure>
<p>What this means is that now every time we call <code>Lists.insert()</code>, <code>Lists.update()</code>, <code>Lists.upsert()</code>, first our document or modifier will be automatically checked against the schema (in subtly different ways depending on the exact mutator).</p>
<h3 id="default-value"><code>defaultValue</code> and data cleaning</h3>

<p>One thing that Collection2 does is <a href="https://github.com/aldeed/meteor-simple-schema#cleaning-data" target="_blank" rel="external">“clean” the data</a> before sending it to the database. This includes but is not limited to:</p>
<ol>
<li>Coercing types - converting strings to numbers</li>
<li>Removing attributes not in the schema</li>
<li>Assigning default values based on the <code>defaultValue</code> in the schema definition</li>
</ol>
<p>However, sometimes it’s useful to do more complex initialization to documents before inserting them into collections. For instance, in the Todos app, we want to set the name of new lists to be <code>List X</code> where <code>X</code> is the next available unique letter.</p>
<p>To do so, we can subclass <code>Mongo.Collection</code> and write our own <code>insert()</code> method:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListsCollection</span> <span class="keyword">extends</span> <span class="title">Mongo</span>.<span class="title">Collection</span> </span>&#123;</span><br><span class="line">  insert(list, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!list.name) &#123;</span><br><span class="line">      <span class="keyword">let</span> nextLetter = <span class="string">'A'</span>;</span><br><span class="line">      list.name = <span class="string">`List <span class="subst">$&#123;nextLetter&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!!<span class="keyword">this</span>.findOne(&#123;<span class="attr">name</span>: list.name&#125;)) &#123;</span><br><span class="line">        <span class="comment">// not going to be too smart here, can go past Z</span></span><br><span class="line">        nextLetter = <span class="built_in">String</span>.fromCharCode(nextLetter.charCodeAt(<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        list.name = <span class="string">`List <span class="subst">$&#123;nextLetter&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the original `insert` method, which will validate</span></span><br><span class="line">    <span class="comment">// against the schema</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.insert(list, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lists = <span class="keyword">new</span> ListsCollection(<span class="string">'lists'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="hooks">Hooks on insert/update/remove</h3>

<p>The technique above can also be used to provide a location to “hook” extra functionality into the collection. For instance, when removing a list, we <em>always</em> want to remove all of its todos at the same time.</p>
<p>We can use a subclass for this case as well, overriding the <code>remove()</code> method:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListsCollection</span> <span class="keyword">extends</span> <span class="title">Mongo</span>.<span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  remove(selector, callback) &#123;</span><br><span class="line">    Package.todos.Todos.remove(&#123;<span class="attr">listId</span>: selector&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.remove(selector, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This technique has a few disadvantages:</p>
<ol>
<li>Mutators can get very long when you want to hook in multiple times.</li>
<li>Sometimes a single piece of functionality can be spread over multiple mutators.</li>
<li>It can be a challenge to write a hook in a completely general way (that covers every possible selector and modifier), and it may not be necessary for your application (because perhaps you only ever call that mutator in one way).</li>
</ol>
<p>A way to deal with points 1. and 2. is to separate out the set of hooks into their own module, and simply use the mutator as a point to call out to that module in a sensible way. We’ll see an example of that <a href="#abstracting-denormalizers">below</a>.</p>
<p>Point 3. can usually be resolved by placing the hook in the <em>Method</em> that calls the mutator, rather than the hook itself. Although this is an imperfect compromise (as we need to be careful if we ever add another Method that calls that mutator in the future), it is better than writing a bunch of code that is never actually called (which is guaranteed to not work!), or giving the impression that your hook is more general that it actually is.</p>
<h3 id="abstracting-denormalizers">Abstracting denormalizers</h3>

<p>Denormalization may need to happen on various mutators of several collections. Therefore, it’s sensible to define the denormalization logic in one place, and hook it into each mutator with one line of code. The advantage of this approach is that the denormalization logic is one place rather than spread over many files, but you can still examine the code for each collection and fully understand what happens on each update.</p>
<p>In the Todos example app, we build a <code>incompleteCountDenormalizer</code> to abstract the counting of incomplete todos on the lists. This code needs to run whenever a todo item is inserted, updated (checked or unchecked), or removed. The code looks like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> incompleteCountDenormalizer = &#123;</span><br><span class="line">  _updateList(listId) &#123;</span><br><span class="line">    <span class="comment">// Recalculate the correct incomplete count direct from MongoDB</span></span><br><span class="line">    <span class="keyword">const</span> incompleteCount = Todos.find(&#123;</span><br><span class="line">      listId,</span><br><span class="line">      <span class="attr">checked</span>: <span class="literal">false</span></span><br><span class="line">    &#125;).count();</span><br><span class="line"></span><br><span class="line">    Lists.update(listId, &#123;<span class="attr">$set</span>: &#123;incompleteCount&#125;&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  afterInsertTodo(todo) &#123;</span><br><span class="line">    <span class="keyword">this</span>._updateList(todo.listId);</span><br><span class="line">  &#125;,</span><br><span class="line">  afterUpdateTodo(selector, modifier) &#123;</span><br><span class="line">    <span class="comment">// We only support very limited operations on todos</span></span><br><span class="line">    check(modifier, &#123;<span class="attr">$set</span>: <span class="built_in">Object</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can only deal with $set modifiers, but that's all we do in this app</span></span><br><span class="line">    <span class="keyword">if</span> (_.has(modifier.$set, <span class="string">'checked'</span>)) &#123;</span><br><span class="line">      Todos.find(selector, &#123;<span class="attr">fields</span>: &#123;<span class="attr">listId</span>: <span class="number">1</span>&#125;&#125;).forEach(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._updateList(todo.listId);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Here we need to take the list of todos being removed, selected *before* the update</span></span><br><span class="line">  <span class="comment">// because otherwise we can't figure out the relevant list id(s) (if the todo has been deleted)</span></span><br><span class="line">  afterRemoveTodos(todos) &#123;</span><br><span class="line">    todos.forEach(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="keyword">this</span>._updateList(todo.listId));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We are then able to wire in the denormalizer into the mutations of the <code>Todos</code> collection like so:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodosCollection</span> <span class="keyword">extends</span> <span class="title">Mongo</span>.<span class="title">Collection</span> </span>&#123;</span><br><span class="line">  insert(doc, callback) &#123;</span><br><span class="line">    doc.createdAt = doc.createdAt || <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">super</span>.insert(doc, callback);</span><br><span class="line">    incompleteCountDenormalizer.afterInsertTodo(doc);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we only handled the mutators we actually use in the application—we don’t deal with all possible ways the todo count on a list could change. For example, if you changed the <code>listId</code> on a todo item, it would need to change the <code>incompleteCount</code> of <em>two</em> lists. However, since our application doesn’t do this, we don’t handle it in the denormalizer.</p>
<p>Dealing with every possible MongoDB operator is difficult to get right, as MongoDB has a rich modifier language. Instead we focus on just dealing with the modifiers we know we’ll see in our app. If this gets too tricky, then moving the hooks for the logic into the Methods that actually make the relevant modifications could be sensible (although you need to be diligent to ensure you do it in <em>all</em> the relevant places, both now and as the app changes in the future).</p>
<p>It could make sense for packages to exist to completely abstract some common denormalization techniques and actually attempt to deal with all possible modifications. If you write such a package, please let us know!</p>
<h2 id="migrations">Migrating to a new schema</h2>

<p>As we discussed above, trying to predict all future requirements of your data schema ahead of time is impossible. Inevitably, as a project matures, there will come a time when you need to change the schema of the database. You need to be careful about how you make the migration to the new schema to make sure your app works smoothly during and after the migration.</p>
<h3 id="writing-migrations">Writing migrations</h3>

<p>A useful package for writing migrations is <a href="https://atmospherejs.com/percolate/migrations" target="_blank" rel="external"><code>percolate:migrations</code></a>, which provides a nice framework for switching between different versions of your schema.</p>
<p>Suppose, as an example, that we wanted to add a <code>list.todoCount</code> field, and ensure that it was set for all existing lists. Then we might write the following in server-only code (e.g. <code>/server/migrations.js</code>):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Migrations.add(&#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="number">1</span>,</span><br><span class="line">  up() &#123;</span><br><span class="line">    Lists.find(&#123;<span class="attr">todoCount</span>: &#123;<span class="attr">$exists</span>: <span class="literal">false</span>&#125;&#125;).forEach(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> todoCount = Todos.find(&#123;<span class="attr">listId</span>: list._id&#125;).count();</span><br><span class="line">      Lists.update(list._id, &#123;<span class="attr">$set</span>: &#123;todoCount&#125;&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  down() &#123;</span><br><span class="line">    Lists.update(&#123;&#125;, &#123;<span class="attr">$unset</span>: &#123;<span class="attr">todoCount</span>: <span class="literal">true</span>&#125;&#125;, &#123;<span class="attr">multi</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This migration, which is sequenced to be the first migration to run over the database, will, when called, bring each list up to date with the current todo count.</p>
<p>To find out more about the API of the Migrations package, refer to <a href="https://atmospherejs.com/percolate/migrations" target="_blank" rel="external">its documentation</a>.</p>
<h3 id="bulk-data-changes">Bulk changes</h3>

<p>If your migration needs to change a lot of data, and especially if you need to stop your app server while it’s running, it may be a good idea to use a <a href="https://docs.mongodb.org/v3.0/core/bulk-write-operations/" target="_blank" rel="external">MongoDB Bulk Operation</a>.</p>
<p>The advantage of a bulk operation is that it only requires a single round trip to MongoDB for the write, which usually means it is a <em>lot</em> faster. The downside is that if your migration is complex (which it usually is if you can’t just do an <code>.update(.., .., {multi: true})</code>), it can take a significant amount of time to prepare the bulk update.</p>
<p>What this means is if users are accessing the site whilst the update is being prepared, it will likely go out of date! Also, a bulk update will lock the entire collection while it is being applied, which can cause a significant blip in your user experience if it takes a while. For these reason, you often need to stop your server and let your users know you are performing maintenance while the update is happening.</p>
<p>We could write our above migration like so (note that you must be on MongoDB 2.6 or later for the bulk update operations to exist). We can access the native MongoDB API via <a href="http://docs.meteor.com/api/collections.html#Mongo-Collection-rawCollection" target="_blank" rel="external"><code>Collection#rawCollection()</code></a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Migrations.add(&#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="number">1</span>,</span><br><span class="line">  up() &#123;</span><br><span class="line">    <span class="comment">// This is how to get access to the raw MongoDB node collection that the Meteor server collection wraps</span></span><br><span class="line">    <span class="keyword">const</span> batch = Lists.rawCollection().initializeUnorderedBulkOp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Mongo throws an error if we execute a batch operation without actual operations, e.g. when Lists was empty.</span></span><br><span class="line">    <span class="keyword">let</span> hasUpdates = <span class="literal">false</span>;</span><br><span class="line">    Lists.find(&#123;<span class="attr">todoCount</span>: &#123;<span class="attr">$exists</span>: <span class="literal">false</span>&#125;&#125;).forEach(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> todoCount = Todos.find(&#123;<span class="attr">listId</span>: list._id&#125;).count();</span><br><span class="line">      <span class="comment">// We have to use pure MongoDB syntax here, thus the `&#123;_id: X&#125;`</span></span><br><span class="line">      batch.find(&#123;<span class="attr">_id</span>: list._id&#125;).updateOne(&#123;<span class="attr">$set</span>: &#123;todoCount&#125;&#125;);</span><br><span class="line">      hasUpdates = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasUpdates)&#123;</span><br><span class="line">      <span class="comment">// We need to wrap the async function to get a synchronous API that migrations expects</span></span><br><span class="line">      <span class="keyword">const</span> execute = Meteor.wrapAsync(batch.execute, batch);</span><br><span class="line">      <span class="keyword">return</span> execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  down() &#123;</span><br><span class="line">    Lists.update(&#123;&#125;, &#123;<span class="attr">$unset</span>: &#123;<span class="attr">todoCount</span>: <span class="literal">true</span>&#125;&#125;, &#123;<span class="attr">multi</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Note that we could make this migration faster by using an <a href="https://docs.mongodb.org/v2.6/aggregation/" target="_blank" rel="external">Aggregation</a> to gather the initial set of todo counts.</p>
<h3 id="running-migrations">Running migrations</h3>

<p>To run a migration against your development database, it’s easiest to use the Meteor shell:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After running `meteor shell` on the command line:</span></span><br><span class="line">Migrations.migrateTo(<span class="string">'latest'</span>);</span><br></pre></td></tr></table></figure>
<p>If the migration logs anything to the console, you’ll see it in the terminal window that is running the Meteor server.</p>
<p>To run a migration against your production database, run your app locally in production mode (with production settings and environment variables, including database settings), and use the Meteor shell in the same way. What this does is run the <code>up()</code> function of all outstanding migrations, against your production database. In our case, it should ensure all lists have a <code>todoCount</code> field set.</p>
<p>A good way to do the above is to spin up a virtual machine close to your database that has Meteor installed and SSH access (a special EC2 instance that you start and stop for the purpose is a reasonable option), and running the command after shelling into it. That way any latencies between your machine and the database will be eliminated, but you still can be very careful about how the migration is run.</p>
<p><strong>Note that you should always take a database backup before running any migration!</strong></p>
<h3 id="breaking-changes">Breaking schema changes</h3>

<p>Sometimes when we change the schema of an application, we do so in a breaking way – so that the old schema doesn’t work properly with the new code base. For instance, if we had some UI code that heavily relied on all lists having a <code>todoCount</code> set, there would be a period, before the migration runs, in which the UI of our app would be broken after we deployed.</p>
<p>The simple way to work around the problem is to take the application down for the period in between deployment and completing the migration. This is far from ideal, especially considering some migrations can take hours to run (although using <a href="#bulk-data-changes">Bulk Updates</a> probably helps a lot here).</p>
<p>A better approach is a multi-stage deployment. The basic idea is that:</p>
<ol>
<li>Deploy a version of your application that can handle both the old and the new schema. In our case, it’d be code that doesn’t expect the <code>todoCount</code> to be there, but which correctly updates it when new todos are created.</li>
<li>Run the migration. At this point you should be confident that all lists have a <code>todoCount</code>.</li>
<li>Deploy the new code that relies on the new schema and no longer knows how to deal with the old schema. Now we are safe to rely on <code>list.todoCount</code> in our UI.</li>
</ol>
<p>Another thing to be aware of, especially with such multi-stage deploys, is that being prepared to rollback is important! For this reason, the migrations package allows you to specify a <code>down()</code> function and call <code>Migrations.migrateTo(x)</code> to migrate <em>back</em> to version <code>x</code>.</p>
<p>So if we wanted to reverse our migration above, we’d run<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The "0" migration is the unmigrated (before the first migration) state</span></span><br><span class="line">Migrations.migrateTo(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>If you find you need to roll your code version back, you’ll need to be careful about the data, and step carefully through your deployment steps in reverse.</p>
<h3 id="migration-caveats">Caveats</h3>

<p>Some aspects of the migration strategy outlined above are possibly not the most ideal way to do things (although perhaps appropriate in many situations). Here are some other things to be aware of:</p>
<ol>
<li><p>Usually it is better to not rely on your application code in migrations (because the application will change over time, and the migrations should not). For instance, having your migrations pass through your Collection2 collections (and thus check schemas, set autovalues etc) is likely to break them over time as your schemas change over time.</p>
<p>One way to avoid this problem is simply to not run old migrations on your database. This is a little bit limiting but can be made to work.</p>
</li>
<li><p>Running the migration on your local machine will probably make it take a lot longer as your machine isn’t as close to the production database as it could be.</p>
</li>
</ol>
<p>Deploying a special “migration application” to the same hardware as your real application is probably the best way to solve the above issues. It’d be amazing if such an application kept track of which migrations ran when, with logs and provided a UI to examine and run them. Perhaps a boilerplate application to do so could be built (if you do so, please let us know and we’ll link to it here!).</p>
<h2 id="associations">Associations between collections</h2>

<p>As we discussed earlier, it’s very common in Meteor applications to have associations between documents in different collections. Consequently, it’s also very common to need to write queries fetching related documents once you have a document you are interested in (for instance all the todos that are in a single list).</p>
<p>To make this easier, we can attach functions to the prototype of the documents that belong to a given collection, to give us “methods” on the documents (in the object oriented sense). We can then use these methods to create new queries to find related documents.</p>
<h3 id="collection-helpers">Collection helpers</h3>

<p>We can use the <a href="https://atmospherejs.com/dburles/collection-helpers" target="_blank" rel="external"><code>dburles:collection-helpers</code></a> package to easily attach such methods (or “helpers”) to documents. For instance:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lists.helpers(&#123;</span><br><span class="line">  <span class="comment">// A list is considered to be private if it has a userId set</span></span><br><span class="line">  isPrivate() &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>.userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Once we’ve attached this helper to the <code>Lists</code> collection, every time we fetch a list from the database (on the client or server), it will have a <code>.isPrivate()</code> function available:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = Lists.findOne();</span><br><span class="line"><span class="keyword">if</span> (list.isPrivate()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The first list is private!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="association-helpers">Association helpers</h3>

<p>Now we can attach helpers to documents, it’s simple to define a helper that fetches related documents</p>
<p>이제 helper를 문서에 첨부 할 수 있으므로 관련 문서를 가져 오는 helper를 정의하는 것이 간단합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lists.helpers(&#123;</span><br><span class="line">  todos() &#123;</span><br><span class="line">    <span class="keyword">return</span> Todos.find(&#123;<span class="attr">listId</span>: <span class="keyword">this</span>._id&#125;, &#123;<span class="attr">sort</span>: &#123;<span class="attr">createdAt</span>: <span class="number">-1</span>&#125;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Now we can easily find all the todos for a list:</p>
<p>이제 목록의 모든 할일을 쉽게 찾을 수 있습니다:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = Lists.findOne();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The first list has <span class="subst">$&#123;list.todos().count()&#125;</span> todos`</span>);</span><br></pre></td></tr></table></figure>

    </div>
  </div>

  <div class="pagination">
    <div class="content-wrapper">
      
      
        <a class="link primary prev"
          href="1.3-migration.html">
          <span class="icon-arrow-left-alt"></span>
          <span class="subtitle-pagination">Previous</span>
          Migrating to Meteor 1.3
        </a>
      
      
        <a class="link primary next"
          href="data-loading.html">
          <span class="subtitle-pagination">Next</span>
          Publications and Data Loading
          <span class="icon-arrow-right-alt"></span>
        </a>
      
    </div>
  </div>

  <div class="github">
    <a class="link tertiary " href="https://github.com/meteor/guide/tree/master/content/collections.md" target="_blank">
      <span class="icon-github"></span>Edit on GitHub</a>
  </div>

  
    <div class="discourse-comments-wrapper content-wrapper">
      <div id='discourse-comments'></div>
    </div>

    <script type="text/javascript">
      DiscourseEmbed = { discourseUrl: 'https://forums.meteor.com/',
                         topicId: 19660 };

      (function() {
        var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
        d.src = DiscourseEmbed.discourseUrl + 'javascripts/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
      })();
    </script>
  
</div>

    <script src="/script/smooth-scroll.min.js"></script>
    <script src="/script/main.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/2.1.8/docsearch.min.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

    <script>
      // nectar ninja
      (function(){
        var handle = '@meteorjs';
        var a = document.createElement('script');
        var m = document.getElementsByTagName('script')[0];
        a.async = 1;
        a.src = 'https://nectar.ninja/api/v1/' + handle.slice(1);
        m.parentNode.insertBefore(a, m);
      })();

     
      
        // Segment Tracking
        !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
        analytics.load("zQx6cQifkTU79E3L0XAnmrOXP2A5bC6r");
        analytics.page()
        }}();
      

      // search box
      

        ['desktop'].forEach(function(type) {
          var search = docsearch({
            apiKey: 'bdf6b09d12024f6bae3631a0dfdd4a7f',
            indexName: 'meteor_api_guide',
            inputSelector: '#' + type + '-search-input',
            autocompleteOptions: {
              dropdownMenuContainer: '.wrapper-' + type + '-search-results',
              debug: true
            },
            algoliaOptions: {
              hitsPerPage: 20
            }
          }).autocomplete;

          var sidebar = document.querySelector('.sidebar-content');
          search.on('autocomplete:opened', function() {
            sidebar.classList.add('searching');
          });
          search.on('autocomplete:closed', function() {
            sidebar.classList.remove('searching');
          });
          search.on('autocomplete:updated', function() {
            if (search.val() === '') {
              search.autocomplete.close();
            }
          });
        });
      

      
        var REDIRECTS = {
  "/using-packages.html": "atmosphere-vs-npm.html",
  "/using-packages.html#npm": "using-npm-packages.html",
  "/using-packages.html#client-npm": "using-npm-packages.html#client-npm",
  "/using-packages.html#installing-npm": "using-npm-packages.html#installing-npm",
  "/using-packages.html#using-npm": "using-npm-packages.html#using-npm",
  "/using-packages.html#npm-styles": "using-npm-packages.html#npm-styles",
  "/using-packages.html#npm-shrinkwrap": "using-npm-packages.html#npm-shrinkwrap",
  "/using-packages.html#atmosphere": "using-atmosphere-packages.html",
  "/using-packages.html#atmosphere-searching": "using-atmosphere-packages.html#atmosphere-searching",
  "/using-packages.html#atmosphere-naming": "using-atmosphere-packages.html#atmosphere-naming",
  "/using-packages.html#installing-atmosphere": "using-atmosphere-packages.html#installing-atmosphere",
  "/using-packages.html#using-atmosphere": "using-atmosphere-packages.html#using-atmosphere",
  "/using-packages.html#importing-atmosphere-styles": "using-atmosphere-packages.html#importing-atmosphere-styles",
  "/using-packages.html#peer-npm-dependencies": "using-atmosphere-packages.html#peer-npm-dependencies",
  "/using-packages.html#package-namespacing": "using-atmosphere-packages.html#package-namespacing",
  "/using-packages.html#async-callbacks": "using-npm-packages.html#async-callbacks",
  "/using-packages.html#bind-environment": "using-npm-packages.html#bind-environment",
  "/using-packages.html#wrap-async": "using-npm-packages.html#wrap-async",
  "/using-packages.html#promises": "using-npm-packages.html#promises",
  "/using-packages.html#overriding-packages": "writing-npm-packages.html#overriding-npm-packages",
  "/using-packages.html#npm-overriding": "writing-npm-packages.html#overriding-npm-packages",
  "/using-packages.html#atmosphere-overriding": "writing-atmosphere-packages.html#overriding-atmosphere-packages",
  "/using-packages.html#npm-shrinkpack": "using-npm-packages.html#npm-shrinkpack",
  "/writing-packages.html": "writing-atmosphere-packages.html",
  "/writing-packages.html#npm-vs-atmosphere": "atmosphere-vs-npm.html",
  "/writing-packages.html#creating-npm": "writing-npm-packages.html",
  "/writing-packages.html#including-in-app": "writing-npm-packages.html#including-in-app",
  "/writing-packages.html#publishing-npm": "writing--packages.html#publishing-npm",
  "/writing-packages.html#creating": "writing-atmosphere-packages.html",
  "/writing-packages.html#adding-files": "writing-atmosphere-packages.html#adding-files",
  "/writing-packages.html#adding-javascript": "writing-atmosphere-packages.html#adding-javascript",
  "/writing-packages.html#adding-css": "writing-atmosphere-packages.html#adding-css",
  "/writing-packages.html#adding-style": "writing-atmosphere-packages.html#adding-style",
  "/writing-packages.html#adding-assests": "writing-atmosphere-packages.html#adding-assets",
  "/writing-packages.html#exporting": "writing-atmosphere-packages.html#exporting",
  "/writing-packages.html#dependencies": "writing-atmosphere-packages.html#dependencies",
  "/writing-packages.html#atmosphere-dependencies": "writing-atmosphere--packages.html#atmosphere-dependencies",
  "/writing-packages.html#meteor-version-dependencies": "writing-atmosphere-packages.html#meteor-version-dependencies",
  "/writing-packages.html#version-constraints": "writing-atmosphere-packages.html#version-constraints",
  "/writing-packages.html#npm-dependencies": "writing-atmosphere-packages.html#npm-dependencies",
  "/writing-packages.html#peer-npm-dependencies": "writing-atmosphere-packages.html#peer-npm-dependencies",
  "/writing-packages.html#cordova-plugins": "writing-atmosphere-packages.html#cordova-plugins",
  "/writing-packages.html#testing": "writing-atmosphere-packages.html#testing",
  "/writing-packages.html#testing-with-peer-dependencies": "writing-atmosphere-packages.html#testing-with-peer-dependencies",
  "/writing-packages.html#local-vs-published": "writing-atmosphere-packages.html#local-vs-published",
  "/writing-packages.html#build-plugins": "build-tool.html#build-plugins",
  "/writing-packages.html#types-of-build-plugins": "build-tool.html#types-of-build-plugins",
  "/writing-packages.html#writing-build-plugins": "build-tool.html#writing-build-plugins",
  "/writing-packages.html#caching-build-plugins": "build-tool.html#caching-build-plugins",
  "/testing.html#simple-unit-test": "testing.html#simple-blaze-unit-test"
};

        function redirect() {
          // Support redirects of the form /path#hash
          var locationKey = location.pathname + location.hash;
          if (REDIRECTS[locationKey]) {
            location.replace(location.origin + '/' + REDIRECTS[locationKey]);
          }

          // Support redirects of the form #hash (works for any path)
          var hashKey = location.hash;
          if (REDIRECTS[hashKey]) {
            location.replace(location.origin + '/' + REDIRECTS[hashKey]);
          }
        }

        // Redirect now
        redirect();

        // Redirect on hash change
        window.onhashchange = redirect;
      
    </script>
  </body>
</html>
