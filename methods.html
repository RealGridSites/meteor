<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <!-- Basic -->
    <title>Methods | Meteor Guide</title>
    <meta name="description" content="How to use Methods, Meteor's remote procedure call system, to write to the database.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/png" href="../images/favicon.png" sizes="16x16 32x32 64x64">

    <!-- Social -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="http://meteor.realgrid.com">
    <meta property="og:title" content="Methods | Meteor Guide">
    <meta property="og:description" content="How to use Methods, Meteor's remote procedure call system, to write to the database.">
    <meta property="og:image" content="">
    <meta name="twitter:card" content="summary_image_large">
    <meta name="twitter:site" content="@meteor">
    <meta name="twitter:title" content="Methods | Meteor Guide">
    <meta name="twitter:description" content="How to use Methods, Meteor's remote procedure call system, to write to the database.">
    <meta name="twitter:image" content="">

    <!-- Misc -->
    <meta name="google-site-verification" content="" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,200,300italic,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/style/style.css">
  </head>
  <body class="">
    

<div class="nav dark">
  <div class="nav-group">
    <div class="nav-item show-mobile">
      <span class="js-sidebar-toggle ">
        <span class="icon-menu"></span>
      </span>
    </div>
    <div class="nav-item">
      <a class="logo-wrapper" href="http://www.meteor.com/developers" title="Meteor Developers Developers"  >
        <img src="../images/logo-coralspace-left.svg" alt="Meteor Developers" class="logo"/>
        <span>Developers</span>
      </a>
    </div>
  </div>

  <div class="nav-group right">
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="http://www.meteor.com/tutorials" target=_new >
          <span>Tutorials</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop active ">
        <a class="link" href="http://guide.meteor.com"  >
          <span>Guide</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="http://docs.meteor.com"  >
          <span>API Docs</span>
        </a>
      </div>
    
      <div class="nav-item show-desktop  ">
        <a class="link" href="https://forums.meteor.com/" target=_new >
          <span>Forums</span>
        </a>
      </div>
    
  </div>
</div>

<div class="sidebar">
  <div class="panel">
    <div class="panel-item">
      <a class="" href="http://www.meteor.com/developers" title="Meteor Developers"  >
        <span>Meteor Developers Developers</span>
      </a>
    </div>
    
      <div class="panel-item "">
        <a class="" href="http://www.meteor.com/tutorials" target=_new >
          <span>Tutorials</span>
        </a>
      </div>
    
      <div class="panel-item active"">
        <a class="" href="http://guide.meteor.com"  >
          <span>Guide</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="http://docs.meteor.com"  >
          <span>API Docs</span>
        </a>
      </div>
    
      <div class="panel-item "">
        <a class="" href="https://forums.meteor.com/" target=_new >
          <span>Forums</span>
        </a>
      </div>
    
  </div>

  <div class="sidebar-content">
    <div class="topcap">
      <span class="title-sidebar">Meteor Guide</span>
      
        <span class="select version-sidebar nochrome">
          <select class="version-select">
            
              <option value="v1.4">1.4</option>
            
              <option value="v1.3">1.3</option>
            
              <option value="v1.2">1.2</option>
            
          </select>
        </span>
      
    </div>

    
    <div class="wrapper-search">
      <div class="input-symbol small round">
        <input type="text" placeholder="Search The Official Guide" id="desktop-search-input" />
        <span class="icon-search"></span>
      </div>
      <div class="wrapper-desktop-search-results"></div>
    </div>

    

    <ul class="toc">
      
        <li>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="index.html" class="sidebar-link ">
                  <span>Introduction</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="code-style.html" class="sidebar-link ">
                  <span>Code Style</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="structure.html" class="sidebar-link ">
                  <span>Application Structure</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="1.4-migration.html" class="sidebar-link ">
                  <span>Migrating to Meteor 1.4</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="1.3-migration.html" class="sidebar-link ">
                  <span>Migrating to Meteor 1.3</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Data</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="collections.html" class="sidebar-link ">
                  <span>Collections and Schemas</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="data-loading.html" class="sidebar-link ">
                  <span>Publications and Data Loading</span>
                </a>
              </li>
            
              
              <li class="item-toc  current">
                <a href="" class="sidebar-link  current">
                  <span>Methods</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="accounts.html" class="sidebar-link ">
                  <span>Users and Accounts</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="testing.html" class="sidebar-link ">
                  <span>Testing</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">View</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="routing.html" class="sidebar-link ">
                  <span>URLs and Routing</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="ui-ux.html" class="sidebar-link ">
                  <span>User Interfaces</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="blaze.html" class="sidebar-link ">
                  <span>Blaze</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="react.html" class="sidebar-link ">
                  <span>React</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="angular.html" class="sidebar-link ">
                  <span>Angular</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Build</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="atmosphere-vs-npm.html" class="sidebar-link ">
                  <span>Atmosphere vs. npm</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="using-atmosphere-packages.html" class="sidebar-link ">
                  <span>Using Atmosphere Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="writing-atmosphere-packages.html" class="sidebar-link ">
                  <span>Writing Atmosphere Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="using-npm-packages.html" class="sidebar-link ">
                  <span>Using npm Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="writing-npm-packages.html" class="sidebar-link ">
                  <span>Writing npm Packages</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="mobile.html" class="sidebar-link ">
                  <span>Mobile</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="build-tool.html" class="sidebar-link ">
                  <span>Build System</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Production</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="security.html" class="sidebar-link ">
                  <span>Security</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="deployment.html" class="sidebar-link ">
                  <span>Deployment and Monitoring</span>
                </a>
              </li>
            
          </ul>
        </li>
      
        <li>
          
            <div class="heading-toc">Meta</div>
          
          <ul class="list-toc">
            
              
              <li class="item-toc ">
                <a href="CONTRIBUTING.html" class="sidebar-link ">
                  <span>Contribution Guidelines</span>
                </a>
              </li>
            
              
              <li class="item-toc ">
                <a href="CHANGELOG.html" class="sidebar-link ">
                  <span>Changelog</span>
                </a>
              </li>
            
          </ul>
        </li>
      
    </ul>
  </div>
</div>

<div class="content">
  <div class="content-wrapper">
    <div class="header-content">
      <h1 class="title-page">Methods</h1>
      
        <div class="subtitle-page">How to use Methods, Meteor's remote procedure call system, to write to the database.</div>
      

      <div class="page-actions">
        <div class="actions-group">
          <a class="btn tertiary small round lowercase" href="https://github.com/meteor/guide/tree/master/content/methods.md" target="_blank"><span class="icon-github"></span> <span>Edit on GitHub</span></a>
          
            <a class="btn tertiary small round lowercase" href="https://forums.meteor.com/t/19662"><span class="icon-comment"></span> <span>Discuss</span></a>
          
        </div>
      </div>
    </div>

    <div class="document-formatting">
      <p>After reading this article, you’ll know:</p>
<ol>
<li>What Methods are in Meteor and how they work in detail.</li>
<li>Best practices for defining and calling Methods.</li>
<li>How to throw and handle errors with Methods.</li>
<li>How to call a Method from a form.</li>
</ol>
<p>이 기사를 읽고 나면 다음을 알게 될 것입니다.</p>
<ol>
<li>Meteor에는 어떤 메소드가 있으며 어떻게 작동하는지 자세히 설명합니다.</li>
<li>메서드를 정의하고 호출하는 모범 사례.</li>
<li>메소드로 에러를 던지고 처리하는 법.</li>
<li>폼에서 메서드를 호출하는 방법.</li>
</ol>
<h2 id="what-is-a-method">What is a Method?</h2>

<p>메소드란?</p>
<p>Methods are Meteor’s remote procedure call (RPC) system, used to save user input events and data that come from the client. If you’re familiar with REST APIs or HTTP, you can think of them like POST requests to your server, but with many nice features optimized for building a modern web application. Later on in this article, we’ll go into detail about some of the benefits you get from Methods that you wouldn’t get from an HTTP endpoint.</p>
<p>메소드는 Meteor의 RPC (Remote Procedure Call) 시스템으로, 클라이언트에서 가져온 사용자 입력 이벤트 및 데이터를 저장하는 데 사용됩니다. REST API 또는 HTTP에 익숙하다면 서버에 대한 POST 요청과 같이 생각할 수 있지만 최신 웹 응용 프로그램을 빌드하는 데 최적화 된 멋진 기능이 많이 있습니다. 이 기사의 뒷부분에서 HTTP 끝점에서 가져올 수없는 메소드의 장점에 대해 자세히 설명합니다.</p>
<p>At its core, a Method is an API endpoint for your server; you can define a Method on the server and its counterpart on the client, then call it with some data, write to the database, and get the return value in a callback. Meteor Methods are also tightly integrated with the pub/sub and data loading systems of Meteor to allow for <a href="http://info.meteor.com/blog/optimistic-ui-with-meteor-latency-compensation" target="_blank" rel="external">Optimistic UI</a>—the ability to simulate server-side actions on the client to make your app feel faster than it actually is.</p>
<p>그것의 중핵에, 방법은 당신의 서버를위한 API 종점이다; 당신은 클라이언트에서 서버와 클라이언트의 메소드를 정의한 다음, 데이터로 호출하고, 데이터베이스에 쓰고, 콜백에서 리턴 값을 얻을 수 있습니다. Meteor Methods는 또한 <a href="http://info.meteor.com/blog/optimistic-ui-with-mete-latency-compensation" target="_blank" rel="external">Optimistic UI</a>를 허용하기 위해 Meteor의 pub / sub 및 데이터로드 시스템과 긴밀하게 통합되어 있습니다 - 클라이언트에서 서버 측 동작을 시뮬레이션하여 앱이 실제보다 더 빠르게 느끼게하는 기능.</p>
<p>We’ll be referring to Meteor Methods with a capital M to differentiate them from class methods in JavaScript.</p>
<p>우리는 Meteor Methods를 대문자 M과 함께 사용하여 JavaScript에서 클래스 메소드와 구별 할 것입니다.</p>
<h2 id="defining-and-calling">Defining and calling Methods</h2>

<p>정의와 메소드호출</p>
<h3 id="basic">Basic Method</h3>

<p>메소드의 기본</p>
<p>In a basic app, defining a Meteor Method is as simple as defining a function. In a complex app, you want a few extra features to make Methods more powerful and easily testable. First, we’re going to go over how to define a Method using the Meteor core API, and in a later section we’ll go over how to use a helpful wrapper package we’ve created to enable a more powerful Method workflow.</p>
<p>기본 앱에서 Meteor 메소드 정의는 함수 정의만큼 간단합니다. 복잡한 응용 프로그램에서는 메서드를보다 강력하고 쉽게 테스트 할 수있는 몇 가지 추가 기능이 필요합니다. 먼저, Meteor core API를 사용하여 Method를 정의하는 방법을 설명하고, 이후 섹션에서는보다 강력한 Method 워크 플로우를 가능하게하기 위해 작성한 유용한 래퍼 패키지를 사용하는 방법을 살펴 보겠습니다.</p>
<h4 id="basic-defining">Defining</h4>

<p>정의하기</p>
<p>Here’s how you can use the built-in <a href="http://docs.meteor.com/#/full/meteor_methods" target="_blank" rel="external"><code>Meteor.methods</code> API</a> to define a Method. Note that Methods should always be defined in common code loaded on the client and the server to enable Optimistic UI. If you have some secret code in your Method, consult the <a href="security.html#secret-code">Security article</a> for how to hide it from the client.</p>
<p>내장 된 <a href="http://docs.meteor.com/#/full/meteor_methods" target="_blank" rel="external"><code>Meteor.methods</code> API</a>를 사용하여 메소드를 정의하는 방법은 다음과 같습니다. 메소드는 Optimistic UI를 사용하기 위해 항상 클라이언트와 서버에로드 된 공통 코드로 정의되어야합니다. 메소드에 비밀 코드가있는 경우 <a href="security.html#secret-code">Security 문서</a>에서 클라이언트에서이를 숨기는 방법을 참조하십시오.</p>
<p>This example uses the <code>aldeed:simple-schema</code> package, which is recommended in several other articles, to validate the Method arguments.</p>
<p>이 예제는 메소드 인수를 확인하기 위해 다른 여러 기사에서 권장하는<code>aldeed:simple-schema</code> 패키지를 사용합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Meteor.methods(&#123;</span><br><span class="line">  <span class="string">'todos.updateText'</span>(&#123; todoId, newText &#125;) &#123;</span><br><span class="line">    <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">      <span class="attr">todoId</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">      <span class="attr">newText</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">    &#125;).validate(&#123; todoId, newText &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> todo = Todos.findOne(todoId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!todo.editableBy(<span class="keyword">this</span>.userId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Meteor.Error(<span class="string">'todos.updateText.unauthorized'</span>,</span><br><span class="line">        <span class="string">'Cannot edit todos in a private list that is not yours'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Todos.update(todoId, &#123;</span><br><span class="line">      <span class="attr">$set</span>: &#123; <span class="attr">text</span>: newText &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="basic-calling">Calling</h4>

<p>호출하기</p>
<p>This Method is callable from the client and server using <a href="http://docs.meteor.com/#/full/meteor_call" target="_blank" rel="external"><code>Meteor.call</code></a>. Note that you should only use a Method in the case where some code needs to be callable from the client; if you just want to modularize code that is only going to be called from the server, use a regular JavaScript function, not a Method.</p>
<p>이 메서드는 <a href="http://docs.meteor.com/#/full/meteor_call" target="_blank" rel="external"><code>Meteor.call</code></a>을 사용하여 클라이언트와 서버에서 호출 할 수 있습니다. 클라이언트에서 일부 코드를 호출 할 수 있어야하는 경우에만 메서드를 사용해야합니다. 서버에서 호출 될 코드 만 모듈화하려는 경우 메서드가 아닌 일반 JavaScript 함수를 사용하십시오.</p>
<p>Here’s how you can call this Method from the client:</p>
<p>다음은 이 메소드를 클라이언트에서 호출하는 방법입니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Meteor.call(<span class="string">'todos.updateText'</span>, &#123;</span><br><span class="line">  <span class="attr">todoId</span>: <span class="string">'12345'</span>,</span><br><span class="line">  <span class="attr">newText</span>: <span class="string">'This is a todo item.'</span></span><br><span class="line">&#125;, (err, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    alert(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// success!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>If the Method throws an error, you get that in the first argument of the callback. If the Method succeeds, you get the result in the second argument and the first argument <code>err</code> will be <code>undefined</code>. For more information about errors, see the section below about error handling.</p>
<p>Method가 오류를 throw하면 콜백의 첫 번째 인수에서 오류가 발생합니다. 메서드가 성공하면 두 번째 인수에서 결과를 가져오고 첫 번째 인수 인 <code>err</code>은 <code>undefined</code>가 됩니다. 오류에 대한 자세한 내용은 오류 처리에 대한 아래 섹션을 참조하십시오.</p>
<h3 id="advanced-boilerplate">Advanced Method boilerplate</h3>

<p>고급 메소드 상용구문</p>
<p>Meteor Methods have several features which aren’t immediately obvious, but every complex app will need them at some point. These features were added incrementally over several years in a backwards-compatible fashion, so unlocking the full capabilities of Methods requires a good amount of boilerplate. In this article we will first show you all of the code you need to write for each feature, then the next section will talk about a Method wrapper package we have developed to make it easier.</p>
<p>Meteor Methods는 당장은 분명하지 않은 몇 가지 기능을 가지고 있지만 모든 복잡한 앱은 어느 시점에서 필요합니다. 이러한 기능은 이전 버전과 호환되는 방식으로 몇 년 동안 점진적으로 추가되었으므로 메소드의 모든 기능을 사용하려면 충분한 양의 상용구가 필요합니다. 이 기사에서는 먼저 각 기능에 대해 작성해야하는 모든 코드를 보여줄 것이고 다음 섹션에서는 더 쉽게 만들 수 있도록 개발 한 Method 래퍼 패키지에 대해 설명 할 것이다.</p>
<p>Here’s some of the functionality an ideal Method would have:</p>
<ol>
<li>Run validation code by itself without running the Method body.</li>
<li>Easily override the Method for testing.</li>
<li>Easily call the Method with a custom user ID, especially in tests (as recommended by the <a href="https://www.discovermeteor.com/blog/meteor-pattern-two-tiered-methods/" target="_blank" rel="external">Discover Meteor two-tiered methods pattern</a>).</li>
<li>Refer to the Method via JS module rather than a magic string.</li>
<li>Get the Method simulation return value to get IDs of inserted documents.</li>
<li>Avoid calling the server-side Method if the client-side validation failed, so we don’t waste server resources.</li>
</ol>
<p>이상적인 메소드가 가질 수있는 몇 가지 기능은 다음과 같습니다.</p>
<ol>
<li>메서드 본문을 실행하지 않고 자체적으로 유효성 검사 코드를 실행합니다.</li>
<li>테스트 방법을 쉽게 재정의하십시오.</li>
<li>특히 사용자 정의 사용자 ID로 메소드를 쉽게 호출하십시오 (<a href="https://www.discovermeteor.com/blog/meteor-pattern-two-tiered-methods/" target="_blank" rel="external">Discover Meteor two-tiered methods pattern</a>).</li>
<li>매직 문자열보다는 JS 모듈을 통한 메소드를 참조하십시오.</li>
<li>Method 시뮬레이션 반환 값을 가져 와서 삽입 된 문서의 ID를 가져옵니다.</li>
<li>클라이언트 측 유효성 검사가 실패한 경우 서버 측 메서드를 호출하지 마십시오. 따라서 서버 자원을 낭비하지 않습니다.</li>
</ol>
<h4 id="advanced-boilerplate-defining">Defining</h4>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> updateText = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'todos.updateText'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factor out validation so that it can be run independently (1)</span></span><br><span class="line">  <span class="comment">// 독립적으로 실행할 수 있도록 유효성 검사를 배제 (1)</span></span><br><span class="line">  validate(args) &#123;</span><br><span class="line">    <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">      <span class="attr">todoId</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">      <span class="attr">newText</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">    &#125;).validate(args)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factor out Method body so that it can be called independently (3)</span></span><br><span class="line">  <span class="comment">// 독립적으로 호출 할 수 있도록 메소드 본문을 인수 분해합니다 (3)</span></span><br><span class="line">  run(&#123; todoId, newText &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> todo = Todos.findOne(todoId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!todo.editableBy(<span class="keyword">this</span>.userId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Meteor.Error(<span class="string">'todos.updateText.unauthorized'</span>,</span><br><span class="line">        <span class="string">'Cannot edit todos in a private list that is not yours'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Todos.update(todoId, &#123;</span><br><span class="line">      <span class="attr">$set</span>: &#123; <span class="attr">text</span>: newText &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call Method by referencing the JS object (4)</span></span><br><span class="line">  <span class="comment">// Also, this lets us specify Meteor.apply options once in</span></span><br><span class="line">  <span class="comment">// the Method implementation, rather than requiring the caller</span></span><br><span class="line">  <span class="comment">// to specify it at the call site.</span></span><br><span class="line">  <span class="comment">// JS 객체를 참조하여 메서드 호출 (4)</span></span><br><span class="line">  <span class="comment">// 또한 Meteor.apply 옵션은 호출자가 호출 사이트에서 Meteor.apply 옵션을 지정하도록</span></span><br><span class="line">  <span class="comment">// 요구하지 않고 Method 구현에서 한번만 지정할 수 있습니다.</span></span><br><span class="line">  call(args, callback) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      <span class="attr">returnStubValue</span>: <span class="literal">true</span>,     <span class="comment">// (5)</span></span><br><span class="line">      throwStubExceptions: <span class="literal">true</span>  <span class="comment">// (6)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Meteor.apply(<span class="keyword">this</span>.name, [args], options, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually register the method with Meteor's DDP system</span></span><br><span class="line"><span class="comment">// 실제로 Meteor의 DDP 시스템으로 메소드 등록</span></span><br><span class="line">Meteor.methods(&#123;</span><br><span class="line">  [updateText.name]: <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    updateText.validate.call(<span class="keyword">this</span>, args);</span><br><span class="line">    updateText.run.call(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="advanced-boilerplate-calling">Calling</h4>

<p>호출하기</p>
<p>Now calling the Method is as simple as calling a JavaScript function:</p>
<p>이제 Method를 호출하는 것은 JavaScript 함수를 호출하는 것처럼 간단합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; updateText &#125; <span class="keyword">from</span> <span class="string">'./path/to/methods.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the Method</span></span><br><span class="line">updateText.call(&#123;</span><br><span class="line">  <span class="attr">todoId</span>: <span class="string">'12345'</span>,</span><br><span class="line">  <span class="attr">newText</span>: <span class="string">'This is a todo item.'</span></span><br><span class="line">&#125;, (err, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    alert(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// success!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the validation only</span></span><br><span class="line">updateText.validate(&#123; <span class="attr">wrong</span>: <span class="string">'args'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the Method with custom userId in a test</span></span><br><span class="line">updateText.run.call(&#123; <span class="attr">userId</span>: <span class="string">'abcd'</span> &#125;, &#123;</span><br><span class="line">  <span class="attr">todoId</span>: <span class="string">'12345'</span>,</span><br><span class="line">  <span class="attr">newText</span>: <span class="string">'This is a todo item.'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>As you can see, this approach to calling Methods results in a better development workflow - you can more easily deal with the different parts of the Method separately and test your code more easily without having to deal with Meteor internals. But this approach requires you to write a lot of boilerplate on the Method definition side.</p>
<p>보다시피 Meteor 내부를 다루지 않고도 Method의 다른 부분을보다 쉽게 처리하고 코드를 더 쉽게 테스트 할 수 있습니다. 그러나이 방법을 사용하려면 메서드 정의 측면에서 많은 상용구를 작성해야합니다.</p>
<h3 id="validated-method">Advanced Methods with mdg:validated-method</h3>

<p>mdg:validated-method를 사용한 고급진 메소드</p>
<p>To alleviate some of the boilerplate that’s involved in correct Method definitions, we’ve published a wrapper package called <code>mdg:validated-method</code> that does most of this for you. Here’s the same Method as above, but defined with the package:</p>
<p>올바른 메소드 정의에 포함 된 일부 보일러 플레이트를 완화하기 위해 우리는 이것을 위해 대부분을 수행하는<code>mdg:validated-method</code>라는 래퍼 패키지를 발표했습니다. 위와 같은 방법이지만 패키지로 정의됩니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ValidatedMethod &#125; <span class="keyword">from</span> <span class="string">'meteor/mdg:validated-method'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> updateText = <span class="keyword">new</span> ValidatedMethod(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'todos.updateText'</span>,</span><br><span class="line">  <span class="attr">validate</span>: <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">todoId</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">    <span class="attr">newText</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;</span><br><span class="line">  &#125;).validator(),</span><br><span class="line">  run(&#123; todoId, newText &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> todo = Todos.findOne(todoId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!todo.editableBy(<span class="keyword">this</span>.userId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Meteor.Error(<span class="string">'todos.updateText.unauthorized'</span>,</span><br><span class="line">        <span class="string">'Cannot edit todos in a private list that is not yours'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Todos.update(todoId, &#123;</span><br><span class="line">      <span class="attr">$set</span>: &#123; <span class="attr">text</span>: newText &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>You call it the same way you call the advanced Method above, but the Method definition is significantly simpler. We believe this style of Method lets you clearly see the important parts - the name of the Method sent over the wire, the format of the expected arguments, and the JavaScript namespace by which the Method can be referenced. Validated methods only accept a single argument and a callback function.</p>
<p>위의 고급 메서드를 호출하는 것과 같은 방식으로 호출하지만 메서드 정의가 훨씬 간단합니다. 이 스타일의 Method를 사용하면 유선을 통해 전송 된 Method의 이름, 예상되는 인수의 형식 및 Method를 참조 할 수있는 JavaScript 네임 스페이스 등 중요한 부분을 명확하게 볼 수 있습니다. Validated 메서드는 단일 인수와 콜백 함수 만 허용합니다.</p>
<h2 id="errors">Error handling</h2>

<p>오류 처리</p>
<p>In regular JavaScript functions, you indicate errors by throwing an <code>Error</code> object. Throwing errors from Meteor Methods works almost the same way, but a bit of complexity is introduced by the fact that in some cases the error object will be sent over a websocket back to the client.</p>
<p>일반적인 자바 스크립트 함수에서는 <code>Error</code> 객체를 던져서 에러를 나타냅니다. Meteor Methods에서 발생하는 오류는 거의 동일한 방식으로 작동하지만 일부 경우에는 오류 객체가 웹 소켓을 통해 클라이언트로 다시 전송된다는 사실 때문에 약간의 복잡성이 발생합니다.</p>
<h3 id="throwing-errors">Throwing errors from a Method</h3>

<p>Meteor introduces two new types of JavaScript errors: <a href="http://docs.meteor.com/#/full/meteor_error" target="_blank" rel="external"><code>Meteor.Error</code></a> and <a href="https://atmospherejs.com/mdg/validation-error" target="_blank" rel="external"><code>ValidationError</code></a>. These and the regular JavaScript <code>Error</code> type should be used in different situations:</p>
<h4 id="internal-server-errors">Regular <code>Error</code> for internal server errors</h4>

<p>내부 서버 오류에 대한 일반적인 <code>Error</code></p>
<p>When you have an error that doesn’t need to be reported to the client, but is internal to the server, throw a regular JavaScript error object. This will be reported to the client as a totally opaque internal server error with no details.</p>
<p>클라이언트에 보고 할 필요가 없지만 서버 내부에 오류가 있으면 일반 JavaScript 오류 객체를 발생시킵니다. 이것은 세부 사항이 없는 완전히 불투명 한 내부 서버 오류로 클라이언트에 보고됩니다.</p>
<h4 id="meteor-error">Meteor.Error for general runtime errors</h4>

<p>일반적인 런타임 오류에 대한 Meteor.Error</p>
<p>When the server was not able to complete the user’s desired action because of a known condition, you should throw a descriptive <code>Meteor.Error</code> object to the client. In the Todos example app, we use these to report situations where the current user is not authorized to complete a certain action, or where the action is not allowed within the app - for example, deleting the last public list.</p>
<p>서버가 알려진 조건으로 인해 사용자가 원하는 작업을 완료 할 수 없으면 설명적인 <code>Meteor.Error</code> 객체를 클라이언트에 던져야합니다. Todos 예제 앱에서는 현재 사용자가 특정 작업을 완료하도록 승인되지 않았거나 앱에서 허용되지 않는 작업 (예:마지막 공개 목록 삭제하는 경우)을 보고합니다.</p>
<p><code>Meteor.Error</code> takes three arguments: <code>error</code>, <code>reason</code>, and <code>details</code>.</p>
<ol>
<li><code>error</code> should be a short, unique, machine-readable error code string that the client can interpret to understand what happened. It’s good to prefix this with the name of the Method for easy internationalization, for example: <code>&#39;todos.updateText.unauthorized&#39;</code>.</li>
<li><code>reason</code> should be a short description of the error for the developer. It should give your coworker enough information to be able to debug the error. The <code>reason</code> parameter should not be printed to the end user directly, since this means you now have to do internationalization on the server before sending the error message, and the UI developer has to worry about the Method implementation when thinking about what will be displayed in the UI.</li>
<li><code>details</code> is optional, and can be used where extra data will help the client understand what is wrong. In particular, it can be combined with the <code>error</code> field to print a more helpful error message to the end user.</li>
</ol>
<p><code>Meteor.Error</code>는<code>error</code>,<code>reason</code>,<code>details</code>의 3가지 인자를 취합니다.</p>
<p>1.<code>error</code>는 클라이언트가 무슨 일이 일어 났는지 이해할 수 있도록 해석 할 수있는 짧고 독특한, 기계가 읽을 수있는 오류 코드 문자열이어야 합니다. 예를 들어 <code>&#39;todos.updateText.unauthorized&#39;</code>와 같이 쉬운 국제화를 위해 Method의 접두사를 접두사로 붙이는 것이 좋습니다.<br>2.<code>reason</code>는 개발자의 오류에 대한 간단한 설명이어야합니다. 오류를 디버그 할 수 있도록 동료에게 충분한 정보를 제공해야 합니다. <code>reason</code> 매개 변수는 최종 사용자에게 직접 출력하면 안됩니다. 오류 메시지를 보내기 전에 서버에서 국제화를해야하므로 UI ​​개발자는 무엇이 될지 생각할 때 메서드 구현에 대해 걱정해야합니다. UI에 표시됩니다.<br>3.<code>details</code>는 선택 사항이며, 추가 데이터가 클라이언트가 무엇이 잘못되었는지를 이해하는 데 도움이되는 곳에 사용될 수 있습니다. 특히 <code>ㄴerror</code> 필드와 결합하여보다 유용한 오류 메시지를 최종 사용자에게 인쇄 할 수 있습니다.</p>
<h4 id="validation-error">ValidationError for argument validation errors</h4>

<p>인수 검증 오류에 대한 ValidationError</p>
<p>When a Method call fails because the arguments are of the wrong type, it’s good to throw a <code>ValidationError</code>. This works just like <code>Meteor.Error</code>, but is a custom constructor that enforces a standard error format that can be read by different form and validation libraries. In particular, if you are calling this Method from a form, throwing a <code>ValidationError</code> will make it easy to display nice error messages next to particular fields in the form.</p>
<p>인수가 잘못된 형식이기 때문에 메서드 호출이 실패하면<code>ValidationError</code>를 throw하는 것이 좋습니다. 이것은 Meteor.Error와 똑같이 작동하지만 다른 폼과 유효성 검사 라이브러리에서 읽을 수있는 표준 오류 형식을 적용하는 사용자 지정 생성자입니다. 특히 폼에서이 메서드를 호출하는 경우 ValidationError를 반환하면 폼의 특정 필드 옆에 멋진 오류 메시지를 쉽게 표시 할 수 있습니다.</p>
<p>When you use <code>mdg:validated-method</code> with <code>aldeed:simple-schema</code> as demonstrated above, this type of error is thrown for you.</p>
<p>위에서 보인 것처럼<code>alded:simple-schema</code>와 함께<code>mdg:validated-method</code>를 사용할 때, 이런 종류의 에러가 발생합니다.</p>
<p>Read more about the error format in the <a href="https://atmospherejs.com/mdg/validation-error" target="_blank" rel="external"><code>mdg:validation-error</code> docs</a>.</p>
<p><a href="https://atmospherejs.com/mdg/validation-error" target="_blank" rel="external"><code>mdg:validation-error</code>s docs</a>에서 오류 형식에 대해 자세히 읽어보십시오.</p>
<h3 id="handling-errors">Handling errors</h3>

<p>오류 처리</p>
<p>When you call a Method, any errors thrown by it will be returned in the callback. At this point, you should identify which error type it is and display the appropriate message to the user. In this case, it is unlikely that the Method will throw a <code>ValidationError</code> or an internal server error, so we will only handle the unauthorized error:</p>
<p>메소드를 호출하면, 메소드가 던진 모든 오류가 콜백으로 리턴됩니다. 이 시점에서 오류 유형을 식별하고 해당 메시지를 사용자에게 표시해야합니다. 이 경우 메서드가 <code>ValidationError</code> 또는 내부 서버 오류를 발생시키지 않으므로 승인되지 않은 오류 만 처리합니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call the Method</span></span><br><span class="line">updateText.call(&#123;</span><br><span class="line">  <span class="attr">todoId</span>: <span class="string">'12345'</span>,</span><br><span class="line">  <span class="attr">newText</span>: <span class="string">'This is a todo item.'</span></span><br><span class="line">&#125;, (err, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.error === <span class="string">'todos.updateText.unauthorized'</span>) &#123;</span><br><span class="line">      <span class="comment">// Displaying an alert is probably not what you would do in</span></span><br><span class="line">      <span class="comment">// a real app; you should have some nice UI to display this</span></span><br><span class="line">      <span class="comment">// error, and probably use an i18n library to generate the</span></span><br><span class="line">      <span class="comment">// message from the error code.</span></span><br><span class="line">      <span class="comment">// 경고를 표시하는 것은 실제 앱에서 하는 것과 다를 수 있습니다.</span></span><br><span class="line">      <span class="comment">// 이 오류를 표시하는 멋진 UI가 있어야하며 아마도 i18n 라이브러리를</span></span><br><span class="line">      <span class="comment">// 사용하여 오류 코드에서 메시지를 생성해야합니다.</span></span><br><span class="line">      alert(<span class="string">'You aren\'t allowed to edit this todo item'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Unexpected error, handle it in the UI somehow</span></span><br><span class="line">      <span class="comment">// 예기치 않은 오류가 발생했습니다. UI에서 처리합니다.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// success!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>We’ll talk about how to handle the <code>ValidationError</code> in the section on forms below.</p>
<p>아래 양식의 섹션에서 ‘ValidationError` 처리 방법에 대해 설명하겠습니다.</p>
<h3 id="throw-stub-exceptions">Errors in Method simulation</h3>

<p>메소드 시뮬레이션 오류</p>
<p>When a Method is called, it usually runs twice—once on the client to simulate the result for Optimistic UI, and again on the server to make the actual change to the database. This means that if your Method throws an error, it will likely fail on the client <em>and</em> the server. For this reason, <code>ValidatedMethod</code> turns on undocumented option in Meteor to avoid calling the server-side implementation if the simulation throws an error.</p>
<p>Method가 호출되면 보통 두 번 실행됩니다. 한 번은 클라이언트에서 낙관적 UI의 결과를 시뮬레이션하고 서버에서는 데이터베이스를 실제로 변경합니다. 즉, 메서드에서 오류가 발생하면 클라이언트 및 서버에서 오류가 발생할 가능성이 큽니다. 이런 이유 때문에 시뮬레이션이 에러를 던지면 서버 측 구현을 호출하지 않기 위해<code>ValidatedMethod</code>는 Meteor의 문서화되지 않은 옵션을 켭니다.</p>
<p>While this behavior is good for saving server resources in cases where a Method will certainly fail, it’s important to make sure that the simulation doesn’t throw an error in cases where the server Method would have succeeded (for example, if you didn’t load some data on the client that the Method needs to do the simulation properly). In this case, you can wrap server-side-only logic in a block that checks for a method simulation:</p>
<p>이 동작은 Method가 확실히 실패 할 경우 서버 리소스를 절약하는 데 유용하지만 서버 메소드가 성공한 경우 시뮬레이션에서 오류가 발생하지 않도록하는 것이 중요합니다 (예 : 메소드가 시뮬레이션을 올바르게 수행해야하는 클라이언트에 일부 데이터로드). 이 경우 메서드 시뮬레이션을 검사하는 블록에 서버 측 논리 만 래핑 할 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.isSimulation) &#123;</span><br><span class="line">  <span class="comment">// Logic that depends on server environment here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="method-form">Calling a Method from a form</h2>

<p>폼으로 부터 메소드 호출하기</p>
<p>The main thing enabled by the <code>ValidationError</code> convention is simple integration between Methods and the forms that call them. In general, your app is likely to have a one-to-one mapping of forms in the UI to Methods. First, let’s define a Method for our business logic:</p>
<p><code>ValidationError</code> 규칙에 의해 가능하게 된 주요한 것은 메소드와 그것들을 호출하는 폼 사이의 단순한 통합입니다. 일반적으로 앱에는 UI의 폼과 메소드의 일대일 매핑이있을 수 있습니다. 먼저, 비즈니스로직을 위한 Method를 정의 해 보겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This Method encodes the form validation requirements.</span></span><br><span class="line"><span class="comment">// By defining them in the Method, we do client and server-side</span></span><br><span class="line"><span class="comment">// validation in one place.</span></span><br><span class="line"><span class="comment">// 이 메서드는 양식 유효성 검사 요구 사항을 인코딩합니다.</span></span><br><span class="line"><span class="comment">// Method에서 정의함으로써 클라이언트측 및 서버측 유효성검증을 한 곳에서 수행합니다.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> insert = <span class="keyword">new</span> ValidatedMethod(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">'Invoices.methods.insert'</span>,</span><br><span class="line">  <span class="attr">validate</span>: <span class="keyword">new</span> SimpleSchema(&#123;</span><br><span class="line">    <span class="attr">email</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">regEx</span>: SimpleSchema.RegEx.Email &#125;,</span><br><span class="line">    <span class="attr">description</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">min</span>: <span class="number">5</span> &#125;,</span><br><span class="line">    <span class="attr">amount</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">regEx</span>: <span class="regexp">/^\d*\.(\d\d)?$/</span> &#125;</span><br><span class="line">  &#125;).validator(),</span><br><span class="line">  run(newInvoice) &#123;</span><br><span class="line">    <span class="comment">// In here, we can be sure that the newInvoice argument is</span></span><br><span class="line">    <span class="comment">// validated.</span></span><br><span class="line">    <span class="comment">// 여기에서는 newInvoice 인수의 유효성을 확인할 수 있습니다.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.userId) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Meteor.Error(<span class="string">'Invoices.methods.insert.not-logged-in'</span>,</span><br><span class="line">        <span class="string">'Must be logged in to create an invoice.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Invoices.insert(newInvoice)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Let’s define a simple HTML form:</p>
<p>간단한 HTML 폼을 정의 해 봅시다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"Invoices_newInvoice"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"Invoices_newInvoice"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"email"</span>&gt;</span>Recipient email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> /&gt;</span></span><br><span class="line">    &#123;&#123;#each error in errors "email"&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-error"</span>&gt;</span>&#123;&#123;error&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"description"</span>&gt;</span>Item description<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"description"</span> /&gt;</span></span><br><span class="line">    &#123;&#123;#each error in errors "description"&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-error"</span>&gt;</span>&#123;&#123;error&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"amount"</span>&gt;</span>Amount owed<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"amount"</span> /&gt;</span></span><br><span class="line">    &#123;&#123;#each error in errors "amount"&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-error"</span>&gt;</span>&#123;&#123;error&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Now, let’s write some JavaScript to handle this form nicely:</p>
<p>이제 이 폼을 잘 처리 할 수있는 JavaScript를 작성해 보겠습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; insert &#125; <span class="keyword">from</span> <span class="string">'../api/invoices/methods.js'</span>;</span><br><span class="line"></span><br><span class="line">Template.Invoices_newInvoice.onCreated(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.errors = <span class="keyword">new</span> ReactiveDict();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Template.Invoices_newInvoice.helpers(&#123;</span><br><span class="line">  errors(fieldName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.errors.get(fieldName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Template.Invoices_newInvoice.events(&#123;</span><br><span class="line">  <span class="string">'submit .Invoices_newInvoice'</span>(event, instance) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">      <span class="attr">email</span>: event.target.email.value,</span><br><span class="line">      <span class="attr">description</span>: event.target.description.value,</span><br><span class="line">      <span class="attr">amount</span>: event.target.amount.value</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    insert.call(data, (err, res) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err.error === <span class="string">'validation-error'</span>) &#123;</span><br><span class="line">          <span class="comment">// Initialize error object</span></span><br><span class="line">          <span class="keyword">const</span> errors = &#123;</span><br><span class="line">            <span class="attr">email</span>: [],</span><br><span class="line">            <span class="attr">description</span>: [],</span><br><span class="line">            <span class="attr">amount</span>: []</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Go through validation errors returned from Method</span></span><br><span class="line">          err.details.forEach(<span class="function">(<span class="params">fieldError</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// XXX i18n</span></span><br><span class="line">            errors[fieldError.name].push(fieldError.type);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Update ReactiveDict, errors will show up in the UI</span></span><br><span class="line">          instance.errors.set(errors);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>보시다시피 폼에 오류를 적절하게 처리하는 데는 상당한 양의 상용구가 있지만 대다수는 기성품 양식 프레임 워크 나 간단한 디자인의 응용 프로그램 별 래퍼로 쉽게 추상화 할 수 있습니다.</p>
<p>As you can see, there is a fair amount of boilerplate to handle errors nicely in a form, but most of it can be easily abstracted by an off-the-shelf form framework or a simple application-specific wrapper of your own design.</p>
<h2 id="loading-data">Loading data with Methods</h2>

<p>메소드로 데이터 로딩</p>
<p>Since Methods can work as general purpose RPCs, they can also be used to fetch data instead of publications. There are some advantages and some disadvantages to this approach compared with loading data through publications, and at the end of the day we recommend always using publications to load data.</p>
<p>Method는 범용 RPC로 작동 할 수 있으므로 게시 대신 데이터를 가져 오는 데에도 사용할 수 있습니다. 게시를 통해 데이터를로드하는 것과 비교하면이 방법에는 몇 가지 장점과 단점이 있으며 하루가 끝날 때마다 항상 데이터를로드하는 데 게시를 사용하는 것이 좋습니다.</p>
<p>Methods can be useful to fetch the result of a complex computation from the server that doesn’t need to update when the server data changes. The biggest disadvantage of fetching data through Methods is that the data won’t be automatically loaded into Minimongo, Meteor’s client-side data cache, so you’ll need to manage the lifecycle of that data manually.</p>
<p>메소드는 서버 데이터가 변경 될 때 업데이트 할 필요가없는 복잡한 계산 결과를 서버에서 가져 오는 데 유용 할 수 있습니다. 메소드를 통해 데이터를 가져 오는 가장 큰 단점은 Meteor의 클라이언트 측 데이터 캐시 인 Minimongo에 데이터가 자동으로로드되지 않으므로 수동으로 해당 데이터의 수명주기를 관리해야한다는 것입니다.</p>
<h4 id="local-collection">Using a local collection to store and display data fetched from a Method</h4>

<p>로컬 콜렉션을 사용하여 메소드에서 가져온 데이터 저장 및 표시</p>
<p>Collections are a very convenient way of storing data on the client side. If you’re fetching data using something other than subscriptions, you can put it in a collection manually. Let’s look at an example where we have a complex algorithm for calculating average scores from a series of games for a number of players. We don’t want to use a publication to load this data because we want to control exactly when it runs, and don’t want the data to be cached automatically.</p>
<p>컬렉션은 클라이언트 측에 데이터를 저장하는 매우 편리한 방법입니다. 구독이 아닌 다른 것을 사용하여 데이터를 가져 오는 경우 수동으로 컬렉션에 넣을 수 있습니다. 여러 플레이어의 일련의 게임에서 평균 점수를 계산하기위한 복잡한 알고리즘이있는 예를 살펴 보겠습니다. 우리는 게시를 사용하여이 데이터를로드하는 것을 원하지 않습니다. 왜냐하면 우리는 정확히 언제 실행되는지 제어하고 데이터를 자동으로 캐시하지 않기를 원하기 때문입니다.</p>
<p>First, you need to create a <em>local collection</em> - this is a collection that exists only on the client side and is not tied to a database collection on the server. Read more in the <a href="http://guide.meteor.com/collections.html#local-collections" target="_blank" rel="external">Collections article</a>.</p>
<p>먼저 <em>local collection</em> 을 만들어야합니다.이 컬렉션은 클라이언트 측에만 존재하며 서버의 데이터베이스 컬렉션에 연결되지 않은 컬렉션입니다. <a href="http://guide.meteor.com/collections.html#local-collections" target="_blank" rel="external">Collections article</a>에서 더 많은 것을 읽으십시오.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In client-side code, declare a local collection</span></span><br><span class="line"><span class="comment">// by passing `null` as the argument</span></span><br><span class="line">ScoreAverages = <span class="keyword">new</span> Mongo.Collection(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>Now, if you fetch data using a Method, you can put into this collection:</p>
<p>이제 Method를 사용하여 데이터를 가져 오면 이 컬렉션에 넣을 수 있습니다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; calculateAverages &#125; <span class="keyword">from</span> <span class="string">'../api/games/methods.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateAverages</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Clean out result cache</span></span><br><span class="line">  ScoreAverages.remove(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call a Method that does an expensive computation</span></span><br><span class="line">  calculateAverages.call(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      ScoreAverages.insert(item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can now use the data from the local collection <code>ScoreAverages</code> inside a UI component exactly the same way we would use a regular MongoDB collection. Instead of it updating automatically, we’ll need to call <code>updateAverages</code> every time we need new results.</p>
<p>이제 UI 컴포넌트 내에서 로컬 컬렉션 <code>ScoreAverages</code>의 데이터를 일반 MongoDB 컬렉션을 사용하는 것과 똑같이 사용할 수 있습니다. 자동으로 업데이트하는 대신 새로운 결과가 필요할 때마다 <code>updateAverages</code>를 호출해야합니다.</p>
<h2 id="advanced">Advanced concepts</h2>

<p>고급 개념</p>
<p>While you can easily use Methods in a simple app by following the Meteor introductory tutorial, it’s important to understand exactly how they work to use them effectively in a production app. One of the downsides of using a framework like Meteor that does a lot for you under the hood is that you don’t always understand what is going on, so it’s good to learn some of the core concepts.</p>
<p>Meteor 입문 자습서를 따라 간단한 응용 프로그램에서 메서드를 쉽게 사용할 수 있지만 프로덕션 응용 프로그램에서 효과적으로 사용하는 방법을 정확히 이해하는 것이 중요합니다. 두뇌 속에서 당신을 위해 많은 일을하는 Meteor와 같은 프레임 워크를 사용하는 단점 중 하나는 당신이 무슨 일이 일어나고 있는지 항상 이해하지 못한다는 것입니다. 따라서 핵심 개념을 배우는 것이 좋습니다.</p>
<h3 id="call-lifecycle">Method call lifecycle</h3>

<p>메소드 호출 라이프사이클</p>
<p>Here’s exactly what happens, in order, when a Method is called:</p>
<p>다음은 메소드가 호출 될 때 순서대로 수행되는 작업입니다.</p>
<h4 id="lifecycle-simulation">1. Method simulation runs on the client</h4>

<p>1 클라이언트에서 메소드 시뮬레이션실행.</p>
<p>If we defined this Method in client and server code, as all Methods should be, a Method simulation is executed in the client that called it.</p>
<p>클라이언트와 서버 코드에서이 메소드를 정의한 경우 모든 메소드가 있어야하므로 메소드 시뮬레이션은 클라이언트를 호출 한 클라이언트에서 실행됩니다.</p>
<p>The client enters a special mode where it tracks all changes made to client-side collections, so that they can be rolled back later. When this step is complete, the user of your app sees their UI update instantly with the new content of the client-side database, but the server hasn’t received any data yet.</p>
<p>클라이언트는 클라이언트 측 모음에 대한 모든 변경 사항을 추적하여 나중에 롤백 할 수 있도록 특수 모드로 전환합니다. 이 단계가 완료되면 앱 사용자는 UI 업데이트를 클라이언트 측 데이터베이스의 새 콘텐츠로 즉시 보지만 서버는 아직 데이터를받지 못했습니다.</p>
<p>If an exception is thrown from the Method simulation, then by default Meteor ignores it and continues to step (2). If you are using <code>ValidatedMethod</code> or pass a special <code>throwStubExceptions</code> option to <code>Meteor.apply</code>, then an exception thrown from the simulation will stop the server-side Method from running at all.</p>
<p>메소드 시뮬레이션에서 예외가 발생하면 기본적으로 Meteor는이를 무시하고 (2) 단계를 계속합니다. <code>ValidatedMethod</code>를 사용하거나 특별한<code>throwStubExceptions</code> 옵션을<code>Meteor.apply</code>에 넘기면, 시뮬레이션에서 던져진 예외는 서버 측 Method가 전혀 실행되지 않게합니다.</p>
<p>The return value of the Method simulation is discarded, unless the <code>returnStubValue</code> option is passed when calling the Method, in which case it is returned to the Method caller. ValidatedMethod passes this option by default.</p>
<p>Method를 호출 할 때<code>returnStubValue</code> 옵션이 전달되지 않는 한 Method 시뮬레이션의 반환 값은 무시됩니다.이 경우 Method 호출자에게 반환됩니다. ValidatedMethod는 기본적으로이 옵션을 전달합니다.</p>
<h4 id="lifecycle-ddp-message">2. A <code>method</code> DDP message is sent to the server</h4>

<p>2 <code>method</code> DDP 메시지가 서버로 전송</p>
<p>The Meteor client constructs a DDP message to send to the server. This includes the Method name, arguments, and an automatically generated Method ID that represents this particular Method invocation.</p>
<p>Meteor 클라이언트는 서버로 전송할 DDP 메시지를 생성합니다. 여기에는 메소드 이름, 인수 및이 특정 메소드 호출을 나타내는 자동 생성 메소드 ID가 포함됩니다.</p>
<h4 id="lifecycle-server">3. Method runs on the server</h4>

<p>3 서버에서 메소드 실행</p>
<p>When the server receives the message, it executes the Method code again on the server. The client side version was a simulation that will be rolled back later, but this time it’s the real version that is writing to the actual database. Running the actual Method logic on the server is crucial because the server is a trusted environment where we know that security-critical code will run the way we expect.</p>
<p>서버가 메시지를 받으면 서버에서 메소드 코드를 다시 실행합니다. 클라이언트 측 버전은 나중에 롤백 될 시뮬레이션 이었지만 이번에는 실제 데이터베이스에 쓰는 실제 버전입니다. 서버가 실제로 중요한 Method 로직을 실행하는 것은 중요합니다. 왜냐하면 서버는 보안이 중요한 코드가 우리가 기대하는대로 작동한다는 것을 알고있는 신뢰할 수있는 환경이기 때문입니다.</p>
<h4 id="lifecycle-result">4. Return value is sent to the client</h4>

<p>4 클라이언트로 반환값 전송</p>
<p>Once the Method has finished running on the server, it sends a <code>result</code> message to the client with the Method ID generated in step 2, and the return value itself. The client stores this for later use, but <em>doesn’t call the Method callback yet</em>. If you pass the <a href="http://docs.meteor.com/#/full/meteor_apply" target="_blank" rel="external"><code>onResultReceived</code> option to <code>Meteor.apply</code></a>, that callback is fired.</p>
<p>메소드가 서버에서 실행되면 메소드는 2 단계에서 생성 된 메소드 ID와 반환 값 자체를 사용하여 ‘결과’메시지를 클라이언트에 보냅니다. 클라이언트는 나중에 사용하기 위해이를 저장하지만 메소드 콜백을 아직 호출하지 않습니다. <a href="http://docs.meteor.com/#/full/meteor_apply" target="_blank" rel="external"><code>Meteor.apply</code> <code>onResultReceived</code> 옵션</a>을 전달하면 콜백이 호출됩니다.</p>
<h4 id="lifecycle-publications">5. Any DDP publications affected by the Method are updated</h4>

<p>5 이 방법으로 영향을받는 모든 DDP 게시가 업데이트됩니다.</p>
<p>If we have any publications on the page that have been affected by the database writes from this Method, the server sends the appropriate updates to the client. Note that the client data system doesn’t reveal these updates to the app UI until the next step.</p>
<p>이 메서드에서 데이터베이스 쓰기로 인해 영향을받은 페이지에 게시가 있으면 서버는 해당 업데이트를 클라이언트에 보냅니다. 클라이언트 데이터 시스템은 다음 단계까지 앱 UI에 이러한 업데이트를 표시하지 않습니다.</p>
<h4 id="lifecycle-updated">6. <code>updated</code> message sent to the client, data replaced with server result, Method callback fires</h4>

<p>6 클라이언트에 전송 된<code>updated</code> 메시지, 서버 결과로 대체 된 데이터, 메소드 콜백 발생</p>
<p>After the relevant data updates have been sent to the correct client, the server sends back the last message in the Method life cycle - the DDP <code>updated</code> message with the relevant Method ID. The client rolls back any changes to client side data made in the Method simulation in step 1, and replaces them with the actual changes sent from the server in step 5.</p>
<p>Lastly, the callback passed to <code>Meteor.call</code> actually fires with the return value from step 4. It’s important that the callback waits until the client is up to date, so that your Method callback can assume that the client state reflects any changes done inside the Method.</p>
<p>관련 데이터 업데이트가 올바른 클라이언트로 전송 된 후 서버는 메소드 라이프 사이클의 마지막 메시지, 즉 관련 메소드 ID가있는 DDP<code>updated</code> 메시지를 되돌려 보냅니다. 클라이언트는 1 단계에서 Method 시뮬레이션으로 작성된 클라이언트 측 데이터에 대한 모든 변경 사항을 롤백하고 5 단계에서 서버에서 전송 된 실제 변경 사항으로 대체합니다.</p>
<p>마지막으로, Meteor.call에 전달 된 콜백은 실제로 4 단계의 리턴 값으로 시작됩니다. 콜백은 클라이언트가 최신 상태가 될 때까지 기다려야합니다. 따라서 메소드 콜백은 클라이언트 상태가 변경 사항을 반영한다고 가정 할 수 있습니다 방법 안에.</p>
<h4 id="lifecycle-error">Error case</h4>

<p>오류 사례</p>
<p>In the list above, we didn’t cover the case when the Method execution on the server throws an error. In that case, there is no return value, and the client gets an error instead. The Method callback is fired instantly with the returned error as the first argument. Read more about error handling in the section about errors below.</p>
<p>위의 목록에서 서버에서 메서드를 실행하면 오류가 발생하는 경우는 다루지 않았습니다. 이 경우 반환 값이 없으며 대신 클라이언트에서 오류가 발생합니다. 메서드 콜백은 반환 된 오류를 첫 번째 인수로 즉시 발생시킵니다. 아래 오류에 대한 섹션에서 오류 처리에 대해 자세히 읽어보십시오.</p>
<h3 id="methods-vs-rest">Benefits of Methods over REST</h3>

<p>REST를 통한 메소드의 이점</p>
<p>We believe Methods provide a much better primitive for building modern applications than REST endpoints built on HTTP. Let’s go over some of the things you get for free with Methods that you would have to worry about if using HTTP. The purpose of this section is not to convince you that REST is bad - it’s just to remind you that you don’t need to handle these things yourself in a Meteor app.</p>
<p>우리는 HTTP를 기반으로 구축 된 REST 끝점보다 현대 응용 프로그램을 작성하는 데 더 나은 방법을 제공한다고 믿습니다. HTTP를 사용하는 경우 걱정할 필요가있는 방법으로 무료로 얻을 수있는 것들 중 일부를 살펴 보겠습니다. 이 섹션의 목적은 REST가 나쁘다는 것을 납득시키는 것이 아니라 Meteor 앱에서 직접 처리 할 필요가 없음을 상기시키는 것입니다.</p>
<h4 id="non-blocking">Methods use synchronous-style APIs, but are non-blocking</h4>

<p>메소드는 동기식 API를 사용하지만 블로킹을 방지합니다.</p>
<p>You may notice in the example Method above, we didn’t need to write any callbacks when interacting with MongoDB, but the Method still has the non-blocking properties that people associate with Node.js and callback-style code. Meteor uses a coroutine library called <a href="https://github.com/laverdet/node-fibers" target="_blank" rel="external">Fibers</a> to enable you to write code that uses return values and throws errors, and avoid dealing with lots of nested callbacks.</p>
<p>위의 예제 메서드에서 MongoDB와 상호 작용할 때 콜백을 작성할 필요가 없지만 사람들이 Node.js 및 콜백 스타일 코드와 연결하는 non-blocking 속성을 여전히 유지합니다. Meteor는 [Fibers] (<a href="https://github.com/laverdet/node-fibers)라는" target="_blank" rel="external">https://github.com/laverdet/node-fibers)라는</a> coroutine 라이브러리를 사용하여 반환 값을 사용하고 오류를 throw하는 코드를 작성하고 많은 중첩 콜백을 처리하지 않도록합니다.</p>
<h4 id="ordered">Methods always run and return in order</h4>

<p>메소드는 항상 실행되고 순서대로 반환됩니다.</p>
<p>When accessing a REST API, you will sometimes run into a situation where you make two requests one after the other, but the results arrive out of order. Meteor’s underlying machinery makes sure this never happens with Methods. When multiple Method calls are received <em>from the same client</em>, Meteor runs each Method to completion before starting the next one. If you need to disable this functionality for one particularly long-running Method, you can use <a href="http://docs.meteor.com/#/full/method_unblock" target="_blank" rel="external"><code>this.unblock()</code></a> to allow the next Method to run while the current one is still in progress. Also, since Meteor is based on Websockets instead of HTTP, all Method calls and results are guaranteed to arrive in the order they are sent. You can also pass a special option <code>wait: true</code> to <code>Meteor.apply</code> to wait to send a particular Method until all others have returned, and not send any other Methods until this one returns.</p>
<p>REST API에 액세스 할 때 때때로 두 개의 요청을 차례로 처리하지만 결과가 순서대로 도착하지 않는 상황이 발생합니다. 유성의 기본 기계는 이것이 결코 방법으로 일어나지 않도록합니다. Meteor는 동일한 client_에서 여러 메소드 호출을 수신하면 다음 메소드를 시작하기 전에 각 메소드를 완료로 실행합니다. 특히 장시간 실행되는 메소드에서이 기능을 비활성화해야하는 경우 [<code>this.unblock ()</code>] (<a href="http://docs.meteor.com/#/full/method_unblock)을" target="_blank" rel="external">http://docs.meteor.com/#/full/method_unblock)을</a> 사용하여 다음 메소드를 사용할 수 있습니다. 현재 진행중인 상태로 실행됩니다. 또한 Meteor는 HTTP 대신 WebSocket을 기반으로하므로 모든 메소드 호출 및 결과는 전송 된 순서대로 도착하도록 보장됩니다. 특별한 메소드<code>wait : true</code>를<code>Meteor.apply</code>에 전달하여 다른 모든 메소드가 리턴 될 때까지 특정 메소드를 보내기를 기다릴 수 있고,이 메소드가 리턴 할 때까지 다른 메소드를 보내지 않을 수 있습니다.</p>
<h4 id="change-tracking">Change tracking for Optimistic UI</h4>

<p>낙관적 UI를위한 변경 추적</p>
<p>When Method simulations and server-side executions run, Meteor tracks any resulting changes to the database. This is what lets the Meteor data system roll back the changes from the Method simulation and replace them with the actual writes from the server. Without this automatic database tracking, it would be very difficult to implement a correct Optimistic UI system.</p>
<p>메소드 시뮬레이션과 서버 측 실행이 실행될 때, Meteor는 데이터베이스에 대한 변경 결과를 추적합니다. 이것은 Meteor 데이터 시스템이 Method 시뮬레이션의 변경 사항을 롤백하고이를 서버의 실제 쓰기로 대체 할 수있게합니다. 이 자동 데이터베이스 추적이 없으면 올바른 낙관적 인 UI 시스템을 구현하는 것이 매우 어려울 것입니다.</p>
<h3 id="calling-method-from-method">Calling a Method from another Method</h3>

<p>다른 메소드에서 메소드 호출하기</p>
<p>Sometimes, you’ll want to call a Method from another Method. Perhaps you already have some functionality implemented and you want to add a wrapper that fills in some of the arguments automatically. This is a totally fine pattern, and Meteor does some nice things for you:</p>
<ol>
<li>Inside a client-side Method simulation, calling another Method doesn’t fire off an extra request to the server - the assumption is that the server-side implementation of the Method will do it. However, it does run the <em>simulation</em> of the called Method, so that the simulation on the client closely matches what will happen on the server.</li>
<li>Inside a Method execution on the server, calling another Method runs that Method as if it were called by the same client. That means the Method runs as usual, and the context - <code>userId</code>, <code>connection</code>, etc - are taken from the original Method call.</li>
</ol>
<p>때로는 다른 Method에서 Method를 호출하기를 원할 것입니다. 아마도 이미 구현 된 일부 기능이 있고 자동으로 인수 중 일부를 채우는 래퍼를 추가하려고합니다. 이것은 완전히 좋은 패턴이며, Meteor는 당신에게 멋진 것들을합니다 :</p>
<ol>
<li>클라이언트 측 Method 시뮬레이션 내에서 다른 Method를 호출해도 서버에 대한 추가 요청이 발생하지 않습니다. Method의 서버 측 구현이이를 수행한다는 가정이 있습니다. 그러나 클라이언트의 시뮬레이션이 서버에서 발생할 일과 거의 일치하도록 호출 된 Method의 <em>simulation</em> 을 실행합니다.</li>
<li>서버에서 메서드를 실행하면 다른 메서드를 호출하면 해당 메서드가 동일한 클라이언트에 의해 호출 된 것처럼 실행됩니다. 즉, Method가 평소와 같이 실행되고, 컨텍스트 인<code>userId</code>,<code>connection</code> 등이 원래 Method 호출에서 가져온 것을 의미합니다.</li>
</ol>
<h3 id="consistent-id-generation">Consistent ID generation and optimistic UI</h3>

<p>일관된 ID 생성 및 낙관적 UI</p>
<p>When you insert documents into Minimongo from the client-side simulation of a Method, the <code>_id</code> field of each document is a random string. When the Method call is executed on the server, the IDs are generated again before being inserted into the database. If it were implemented naively, it could mean that the IDs generated on the server are different, which would cause undesirable flickering and re-renders in the UI when the Method simulation was rolled back and replaced with the server data. But this is not the case in Meteor!</p>
<p>메소드의 클라이언트 측 시뮬레이션으로부터 Minimongo에 문서를 삽입 할 때, 각 문서의<code>_id</code> 필드는 임의의 문자열입니다. 메소드 호출이 서버에서 실행될 때 ID는 데이터베이스에 삽입되기 전에 다시 생성됩니다. 순진하게 구현 된 경우 서버에서 생성 된 ID가 달라져서 메소드 시뮬레이션이 롤백되고 서버 데이터로 바뀌면 UI에서 바람직하지 않은 깜박임 및 다시 렌더링이 발생할 수 있습니다. 그러나 유성에서는 그렇지 않습니다!</p>
<p>Each Meteor Method invocation shares a random generator seed with the client that called the Method, so any IDs generated by the client and server Methods are guaranteed to be the same. This means you can safely use the IDs generated on the client to do things while the Method is being sent to the server, and be confident that the IDs will be the same when the Method finishes. One case where this is particularly useful is if you want to create a new document in the database, then immediately redirect to a URL that contains that new document’s ID.</p>
<p>각 Meteor 메소드 호출은 메소드를 호출 한 클라이언트와 임의의 생성자 시드를 공유하므로 클라이언트와 서버 메소드에 의해 생성 된 ID는 동일하게 보장됩니다. 즉, 메소드가 서버로 전송되는 동안 클라이언트에서 생성 된 ID를 안전하게 사용할 수 있으며 메소드가 완료 될 때 ID가 동일해질 것이라고 확신 할 수 있습니다. 특히 데이터베이스에서 새 문서를 만든 다음 해당 새 문서의 ID가 포함 된 URL로 즉시 리디렉션하려는 경우에 특히 유용합니다.</p>
<h3 id="retries">Method retries</h3>

<p>메소드 재 시도</p>
<p>If you call a Method from the client, and the user’s Internet connection disconnects before the result is received, Meteor assumes that the Method didn’t actually run. When the connection is re-established, the Method call will be sent again. This means that, in certain situations, Methods can be sent more than once. This should only happen very rarely, but in the case where an extra Method call could have negative consequences it is worth putting in extra effort to ensure that Methods are idempotent - that is, calling them multiple times doesn’t result in additional changes to the database.</p>
<p>결과를 수신하기 전에 클라이언트에서 메소드를 호출하고 사용자의 인터넷 연결이 끊어지면 Meteor는 메소드가 실제로 실행되지 않았다고 가정합니다. 연결이 다시 설정되면 메서드 호출이 다시 전송됩니다. 즉, 특정 상황에서 메소드를 두 번 이상 보낼 수 있습니다. 이것은 매우 드물게 발생하지만 추가 메서드 호출이 부정적인 결과를 초래할 수있는 경우 메서드가 멱등수인지 확인하기 위해 추가 작업을 할 가치가 있습니다. 즉 여러 번 호출하면 결과가 추가로 변경되지 않습니다. 데이터 베이스.</p>
<p>Many Method operations are idempotent by default. Inserts will throw an error if they happen twice because the generated ID will conflict. Removes on collections won’t do anything the second time, and most update operators like <code>$set</code> will have the same result if run again. The only places you need to worry about code running twice are MongoDB update operators that stack, like <code>$inc</code> and <code>$push</code>, and calls to external APIs.</p>
<p>많은 메소드 조작은 기본적으로 멱등 원입니다. 생성 된 ID가 충돌하기 때문에 삽입이 두 번 발생하면 오류가 발생합니다. 콜렉션에서의 제거는 두 번째로 아무것도하지 않을 것이고<code>$ set</code>과 같은 대부분의 갱신 연산자는 다시 실행하면 같은 결과를 갖습니다. 두 번 실행되는 코드에 대해 걱정할 필요가있는 곳은<code>$ inc</code>와<code>$ push</code>처럼 스택하는 MongoDB 업데이트 연산자와 외부 API 호출입니다.</p>
<h3 id="comparison-with-allow-deny">Historical comparison with allow/deny</h3>

<p>allow/deny의 과거 비교</p>
<p>The Meteor core API includes an alternative to Methods for manipulating data from the client. Instead of explicitly defining Methods with specific arguments, you can instead call <code>insert</code>, <code>update</code>, and <code>remove</code> directly from the client and specify security rules with <a href="http://docs.meteor.com/#/full/allow" target="_blank" rel="external"><code>allow</code></a> and <a href="http://docs.meteor.com/#/full/deny" target="_blank" rel="external"><code>deny</code></a>. In the Meteor Guide, we are taking a strong position that this feature should be avoided and Methods used instead. Read more about the problems with allow/deny in the <a href="security.html#allow-deny">Security article</a>.</p>
<p>Meteor 핵심 API는 클라이언트에서 데이터를 조작하기위한 메소드 대신 사용할 수 있습니다. 특정 인자를 가진 메소드를 명시 적으로 정의하는 대신 클라이언트에서 직접<code>insert</code>,<code>update</code> 및<code>remove</code>를 호출하고 [<code>allow</code>]로 보안 규칙을 지정할 수 있습니다 (<a href="http://docs.meteor.com/" target="_blank" rel="external">http://docs.meteor.com/</a> # / 전체 / 허용) 및 [<code>거부</code>] (<a href="http://docs.meteor.com/#/full/deny" target="_blank" rel="external">http://docs.meteor.com/#/full/deny</a>). 유성 가이드에서 우리는이 기능을 피해야하고 대신 메쏘드를 사용해야한다는 강력한 입장을 취하고 있습니다. [보안 기사] (security.html # allow-deny)에서 허용 / 거부 문제에 대해 자세히 알아보십시오.</p>
<p>Historically, there have been some misconceptions about the features of Meteor Methods as compared with the allow/deny feature, including that it was more difficult to achieve Optimistic UI when using Methods. However, the client-side <code>insert</code>, <code>update</code>, and <code>remove</code> feature is actually implemented <em>on top of</em> Methods, so Methods are strictly more powerful. You get great default Optimistic UI just by defining your Method code on the client and the server, as described in the Method lifecycle section above.</p>
<p>역사적으로 메테오 메소드의 기능에 대한 오해가 허용 / 거부 기능에 비해 오히려 나타났습니다. 여기에는 메소드 사용시 낙관적 인 UI를 얻기가 더 어려웠습니다. 그러나, 클라이언트 측의<code>insert</code>,<code>update</code>,<code>remove</code> 기능은 실제로 메소드들 중 가장 위에 구현되어 있으므로, 메소드는 더 강력합니다. 위 메소드 라이프 사이클 섹션에 설명 된대로 클라이언트와 서버에 메소드 코드를 정의하는 것만으로 훌륭한 기본 Optimistic UI를 얻을 수 있습니다.</p>

    </div>
  </div>

  <div class="pagination">
    <div class="content-wrapper">
      
      
        <a class="link primary prev"
          href="data-loading.html">
          <span class="icon-arrow-left-alt"></span>
          <span class="subtitle-pagination">Previous</span>
          Publications and Data Loading
        </a>
      
      
        <a class="link primary next"
          href="accounts.html">
          <span class="subtitle-pagination">Next</span>
          Users and Accounts
          <span class="icon-arrow-right-alt"></span>
        </a>
      
    </div>
  </div>

  <div class="github">
    <a class="link tertiary " href="https://github.com/meteor/guide/tree/master/content/methods.md" target="_blank">
      <span class="icon-github"></span>Edit on GitHub</a>
  </div>

  
    <div class="discourse-comments-wrapper content-wrapper">
      <div id='discourse-comments'></div>
    </div>

    <script type="text/javascript">
      DiscourseEmbed = { discourseUrl: 'https://forums.meteor.com/',
                         topicId: 19662 };

      (function() {
        var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
        d.src = DiscourseEmbed.discourseUrl + 'javascripts/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
      })();
    </script>
  
</div>

    <script src="/script/smooth-scroll.min.js"></script>
    <script src="/script/main.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/docsearch.js/2.1.8/docsearch.min.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

    <script>
      // nectar ninja
      (function(){
        var handle = '@meteorjs';
        var a = document.createElement('script');
        var m = document.getElementsByTagName('script')[0];
        a.async = 1;
        a.src = 'https://nectar.ninja/api/v1/' + handle.slice(1);
        m.parentNode.insertBefore(a, m);
      })();

     
      
        // Segment Tracking
        !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
        analytics.load("zQx6cQifkTU79E3L0XAnmrOXP2A5bC6r");
        analytics.page()
        }}();
      

      // search box
      

        ['desktop'].forEach(function(type) {
          var search = docsearch({
            apiKey: 'bdf6b09d12024f6bae3631a0dfdd4a7f',
            indexName: 'meteor_api_guide',
            inputSelector: '#' + type + '-search-input',
            autocompleteOptions: {
              dropdownMenuContainer: '.wrapper-' + type + '-search-results',
              debug: true
            },
            algoliaOptions: {
              hitsPerPage: 20
            }
          }).autocomplete;

          var sidebar = document.querySelector('.sidebar-content');
          search.on('autocomplete:opened', function() {
            sidebar.classList.add('searching');
          });
          search.on('autocomplete:closed', function() {
            sidebar.classList.remove('searching');
          });
          search.on('autocomplete:updated', function() {
            if (search.val() === '') {
              search.autocomplete.close();
            }
          });
        });
      

      
        var REDIRECTS = {
  "/using-packages.html": "atmosphere-vs-npm.html",
  "/using-packages.html#npm": "using-npm-packages.html",
  "/using-packages.html#client-npm": "using-npm-packages.html#client-npm",
  "/using-packages.html#installing-npm": "using-npm-packages.html#installing-npm",
  "/using-packages.html#using-npm": "using-npm-packages.html#using-npm",
  "/using-packages.html#npm-styles": "using-npm-packages.html#npm-styles",
  "/using-packages.html#npm-shrinkwrap": "using-npm-packages.html#npm-shrinkwrap",
  "/using-packages.html#atmosphere": "using-atmosphere-packages.html",
  "/using-packages.html#atmosphere-searching": "using-atmosphere-packages.html#atmosphere-searching",
  "/using-packages.html#atmosphere-naming": "using-atmosphere-packages.html#atmosphere-naming",
  "/using-packages.html#installing-atmosphere": "using-atmosphere-packages.html#installing-atmosphere",
  "/using-packages.html#using-atmosphere": "using-atmosphere-packages.html#using-atmosphere",
  "/using-packages.html#importing-atmosphere-styles": "using-atmosphere-packages.html#importing-atmosphere-styles",
  "/using-packages.html#peer-npm-dependencies": "using-atmosphere-packages.html#peer-npm-dependencies",
  "/using-packages.html#package-namespacing": "using-atmosphere-packages.html#package-namespacing",
  "/using-packages.html#async-callbacks": "using-npm-packages.html#async-callbacks",
  "/using-packages.html#bind-environment": "using-npm-packages.html#bind-environment",
  "/using-packages.html#wrap-async": "using-npm-packages.html#wrap-async",
  "/using-packages.html#promises": "using-npm-packages.html#promises",
  "/using-packages.html#overriding-packages": "writing-npm-packages.html#overriding-npm-packages",
  "/using-packages.html#npm-overriding": "writing-npm-packages.html#overriding-npm-packages",
  "/using-packages.html#atmosphere-overriding": "writing-atmosphere-packages.html#overriding-atmosphere-packages",
  "/using-packages.html#npm-shrinkpack": "using-npm-packages.html#npm-shrinkpack",
  "/writing-packages.html": "writing-atmosphere-packages.html",
  "/writing-packages.html#npm-vs-atmosphere": "atmosphere-vs-npm.html",
  "/writing-packages.html#creating-npm": "writing-npm-packages.html",
  "/writing-packages.html#including-in-app": "writing-npm-packages.html#including-in-app",
  "/writing-packages.html#publishing-npm": "writing--packages.html#publishing-npm",
  "/writing-packages.html#creating": "writing-atmosphere-packages.html",
  "/writing-packages.html#adding-files": "writing-atmosphere-packages.html#adding-files",
  "/writing-packages.html#adding-javascript": "writing-atmosphere-packages.html#adding-javascript",
  "/writing-packages.html#adding-css": "writing-atmosphere-packages.html#adding-css",
  "/writing-packages.html#adding-style": "writing-atmosphere-packages.html#adding-style",
  "/writing-packages.html#adding-assests": "writing-atmosphere-packages.html#adding-assets",
  "/writing-packages.html#exporting": "writing-atmosphere-packages.html#exporting",
  "/writing-packages.html#dependencies": "writing-atmosphere-packages.html#dependencies",
  "/writing-packages.html#atmosphere-dependencies": "writing-atmosphere--packages.html#atmosphere-dependencies",
  "/writing-packages.html#meteor-version-dependencies": "writing-atmosphere-packages.html#meteor-version-dependencies",
  "/writing-packages.html#version-constraints": "writing-atmosphere-packages.html#version-constraints",
  "/writing-packages.html#npm-dependencies": "writing-atmosphere-packages.html#npm-dependencies",
  "/writing-packages.html#peer-npm-dependencies": "writing-atmosphere-packages.html#peer-npm-dependencies",
  "/writing-packages.html#cordova-plugins": "writing-atmosphere-packages.html#cordova-plugins",
  "/writing-packages.html#testing": "writing-atmosphere-packages.html#testing",
  "/writing-packages.html#testing-with-peer-dependencies": "writing-atmosphere-packages.html#testing-with-peer-dependencies",
  "/writing-packages.html#local-vs-published": "writing-atmosphere-packages.html#local-vs-published",
  "/writing-packages.html#build-plugins": "build-tool.html#build-plugins",
  "/writing-packages.html#types-of-build-plugins": "build-tool.html#types-of-build-plugins",
  "/writing-packages.html#writing-build-plugins": "build-tool.html#writing-build-plugins",
  "/writing-packages.html#caching-build-plugins": "build-tool.html#caching-build-plugins",
  "/testing.html#simple-unit-test": "testing.html#simple-blaze-unit-test"
};

        function redirect() {
          // Support redirects of the form /path#hash
          var locationKey = location.pathname + location.hash;
          if (REDIRECTS[locationKey]) {
            location.replace(location.origin + '/' + REDIRECTS[locationKey]);
          }

          // Support redirects of the form #hash (works for any path)
          var hashKey = location.hash;
          if (REDIRECTS[hashKey]) {
            location.replace(location.origin + '/' + REDIRECTS[hashKey]);
          }
        }

        // Redirect now
        redirect();

        // Redirect on hash change
        window.onhashchange = redirect;
      
    </script>
  </body>
</html>
